{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            width: 100%;
            margin: 0;
        }

        #main_cont {
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            border-radius: 7px;
            padding: 10px;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(255, 156, 156);
        }

        #unlocked {
            background: url("https://rare-gallery.com/mocahbig/430714-abstract-glitch-art-digital-art.jpg");
            background-size: cover;
            background-position: bottom;
            width: 500px;
            height: 100px;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 5px;
            overflow-y: scroll;
            font-size: 1.7em;
            padding: 10px;
            color: white;
        }

        .fragment {
            border-radius: 3px;
            color: white;
            padding: 3px;
        }

        #fragments {
            display: flex;
            border: 1px solid blue;
            border-radius: 5px;
            padding: 10px;
            flex-wrap: wrap;
            gap: 5px;
        }

        #hint {
            font-size: 0.6em;
            text-align: center;
        }

        .stylized-button {
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            background-color: #0056b3;
            transform: scale(1.05);
        }
    </style>
</head>

<body>
    <div id="main_cont">
        <div id="unlocked">
            <div id="hint">
                Corrupted fragments<br>
                Remove by clicking. Can remove up to 3 per message.
            </div>
            <div id="fragments">
            </div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", async function () {
            const main_cont = document.getElementById("main_cont")

            //load ai reply
            const newGenSwipes = await getChatMessages('{{lastMessageId}}', {include_swipes: true})[0]
            let input = newGenSwipes["swipes"][newGenSwipes["swipe_id"]]
            const origInput = input


            //load chatdata
            let swiped
            let toCut
            let removeCount
            let toReplace
            let userMesEdited
            let chatData = `{{getvar::chatData}}`
            if (chatData == "") {
                triggerSlash(`/setvar key=chatData {}`)
                swiped = false
                toCut = true
                removeCount = 3
                toReplace = []
                toReplace.push(genCorruptFragment())
                toReplace.push(genCorruptFragment())
                toReplace.push(genCorruptFragment())
                toReplace.push(genCorruptFragment())
                toReplace.push(genCorruptFragment())
                userMesEdited = false
            }
            else {
                chatData = JSON.parse(getVariables()["chatData"])
                swiped = chatData["swiped"]
                toCut = chatData["toCut"]
                toReplace = chatData["toReplace"]
                removeCount = chatData["removeCount"]
                userMesEdited = false
            }


            function saveData() {
                chatData = {
                    "swiped": swiped,
                    "toCut": toCut,
                    "toReplace": toReplace,
                    "removeCount": removeCount,
                    "userMesEdited": userMesEdited
                }
                triggerSlash(`/setvar key=chatData ${JSON.stringify(chatData)}`)
            }


            //verifiers
            if (input == "") {
                main_cont.parentNode.removeChild(main_cont)
                saveData()
                return
            }


            const regexDialogues = /\"[^\"]+?\"/gi
            let dialogues = getMatches(regexDialogues, input)
            let fragmentsOrig = []


            //swipe handler
            eventOnce(tavern_events.MESSAGE_SWIPED, function () {
                //change some data and save everything before swipe
                swiped = true
                toCut = true
                saveData()
            })
            if(swiped) {
                const swipes = await getChatMessages('{{lastMessageId}}', {include_swipes: true})[0]["swipes"]
                const swipeGen = newGenSwipes["swipes"][newGenSwipes["swipe_id"]]
                if(swipeGen === "...") {
                    saveData()
                    return
                }
                input = swipeGen
                swiped = false
            }
            //main script func here
            encryptFragments()
            updateInput()
            updateFragments()
            updateAIMes()
            saveData()


            function encryptFragments() {
                dialogues.forEach(dialogueObj => {
                    let dialogue = dialogueObj["match"]
                    toReplace.forEach(fragment => {
                        dialogue = dialogue.replaceAll(RegExp(fragment, "gi"), atCount(fragment.length))
                    });
                    dialogues = replaceElement(dialogues, dialogueObj["match"], dialogue)
                })
            }


            function onFragmentClick(e) {
                if(removeCount <= 0) {
                    return
                }
                
                const elem = e.target
                toReplace = toReplace.filter(fragment => fragment !== elem.innerText)
                removeCount--
                updateFragments()
                saveData()
            }


            function getMatches(regex, str) {
                const matches = [];
                const matchR = str.matchAll(regex)
                for (const match of matchR) {
                    matches.push({
                        match: match[0],
                        index: match.index, // Use match.index instead of match["index"]
                        original: match[0]
                    });
                }
                return matches;
            }


            function genCorruptFragment() {
                const c = ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","z"]
                const v = ["a", "e", "i", "o", "u", "y"]
                const patterns = ["cv", "cc", "vc", "vv"]
                let output = ""
                while(output === "" || containsString(toReplace, output)) {
                    output = ""
                    let len = [1,2,2,2,2]
                    let pattern = patterns[Math.floor(Math.random() * patterns.length)]
                    len = len[Math.floor(Math.random() * len.length)]
                    if(len === 2) {
                        switch(pattern) {
                            case "cv":
                                output += c[Math.floor(Math.random() * c.length)]
                                output += v[Math.floor(Math.random() * v.length)]
                            break
                            case "cc":
                                output += c[Math.floor(Math.random() * c.length)]
                                output += c[Math.floor(Math.random() * c.length)]
                            break
                            case "vc":
                                output += v[Math.floor(Math.random() * v.length)]
                                output += c[Math.floor(Math.random() * c.length)]
                            break
                            case "vv":
                                output += v[Math.floor(Math.random() * v.length)]
                                output += v[Math.floor(Math.random() * v.length)]
                            break
                            default: console.error("Error on gen corrupt fragment.")
                        }
                    }
                    else {
                        let cv = [c,v]
                        cv = cv[Math.floor(Math.random() * cv.length)]
                        output = cv[Math.floor(Math.random() * cv.length)]
                    }
                }

                return output
            }


            function containsString(array, str) { //case insensitive
                return array.some(item => item.toLowerCase() === str.toLowerCase());
            }


            
            function atCount(count) {
                const corrupt = ["#Ì¢Ì·Ì¶Ì´Ì¸Ì¶Ò‰Ì¨Ì¡Ì·Ì·Ì¨Ì›Ì¢Ì·Ì¸Ò‰Ì´Ì¡Ì¨Ì´Ì¢Ì¶Ì¨@Ì·Ì¢ÌµÌ¢Ì¡Ì¡Ì¡Ì›Ì¡Ì¸Ì›ÌµÒ‰Ì´Ì¸Ì¡Ì¸Ì·Ì¡Ì´Ì´Ì¶Ì¶Ì¶", "#ÌµÍ Ì•Ì½Í€ÌÌ¿Ì‘ÌÍÌ€Ì„ÍŠÌ…Ì„Ì‚Ì‚ÌšÌ‹ÌÌ†ÌÌ‘ÍŒÌˆÍ›ÍŠÍÌˆÌ›Í ÌŒÍŠÍ ÍŒÌ€Í„ÌÍÍ„Ì€Ì‘ÍÍÌƒÍ„ÍÌ¿Ì‚ÌÌÍ‚ÌÌ†ÍÍ’Ì½ÌÍÌÍ‚Ì…Ì‡Í€ÌÌ¾Ì‘ÍŠÌ“ÍŠÌ€Ì…ÌÍ†Í„ÍƒÍÍ„Ì“ÌÌ€Ì‰Ì’Ì³Ì¬@Ì¶Ì’ÌŠÌ‚Í‘ÍÍŒÌ•ÌÍŠÌ‚Í‹Í†ÌŒÍ‘ÌˆÌÌÌ’Ì¿Ì‡Ì“Ì”ÌÌŠÍ˜Ì„Ì‰ÍÌ½Í‘Í˜ÍƒÌ†Í€Ì‚Í˜Ì‡Ì¿Ì‘ÌÌÌŠÍ‹ÍÍÌ”Í˜ÌŒÌÍ‘Ì‡Ì¾Ì…Í‹ÍÌŒÌÌ®Ì»Ì»ÍÍ•Í™Ì™ÌºÌ¥Ì«Ì­ÍœÌºÌ¬Ì Ì®ÍœÌ¹Ì¥ÌÌÍÍÌ²Ì«Ì¤Í“Ì«Ì¦Ì£Í–Ì§Í…Ì¬Ì­Ì¥ÌœÌ®ÌªÌÌ¡Ì»Ì©Ì«Í–ÌªÌ§Ì–Ì¼Ì®Ì¨ÍœÍšÌ£Ì«Í“Ì¯Ì¨Ì¨Í“Ì®Ì¬Ì»Ì«Ì³Ì¤Í“Ì–ÍÌŸÌ¢Ì±ÌªÌ¹Ì«Ì¥Ìª", "â˜¤ Ì”Ì“#Ì´ÍŸÌ‘Í€Ì”Í˜@Ì¢ÍÌ´Ì‘ â˜¤", "ğŸ–âœ", "ğŸ–šğŸ–Œ", "ê§ê§‚", "#ÌµÌŒÌ…ÌÌˆÌŠÌÌÌ…Í„Í„Í„ÌÍ„Ì‘ÍÌÍ„Í‹ÌˆÍÌ•ÍŠÌ‚Í„ÌŒÍ€Í—Í›Í„ÍÌÍÌ’Í—Ì•Í‚Ì½Í’Ì•Ì¾Í„Ì‹ÍÌ¾ÌˆÌ…Ì“ÍÌÍÍ‚Ì„Ì€Í—ÍÍƒÌ†Ì¿Ì”Í‹Í‚Í Í‘Ì€Í€Í„Ì”Í€Í Ì€Ì’Ì½ÌÌÍÍ ÍÍ˜ÍÍ’ÍŠÌŒÌ’Ì‚Í‹Í‚Í‹Ì‘Ì‘Í„Í’Ì”Í†Ì’ÌšÍ„ÍÍŒÍ„Ì›Ì¢Ì«Ì®Ì­Ì¯ÍšÌ¤Ì©ÌœÍ–ÍˆÌ¦ÌÍ…Í–Ì³Ì®ÌºÍœÍ“Í“ÍÍÌ¼ÌŸÌŸÌ²ÌªÌ¤Ì¨@Ì·ÍÍ‚ÍÍÌÌ…Í—Í‘Í’ÌÌ½Ì‡Ì…Í„Ì…ÌšÌšÌšÌ½ÌƒÌƒÌ¿Ì‘Í‹Í Ì‹Ì½Ì‹Í€Ì’Ì…Ì’Ì“ÍŠÍ‹Í†Í€Ì¿Ì‹Ì’Í‹Ì†Í„ÍŠÍÍÍƒÌ‡Ì‡Í‘ÌŒÌÌ½Í€Ì›ÌˆÍÌ•ÌŒÌŠÍ„Ì’ÌšÌ“ÍƒÌ†Ì¾Ì’Í‚Ì‘ÌÌ†Í›Ì•Ì‚ÌÌŒÌ…Í Ì“Ì¾ÌÌÍŒÌ‘ÌÍ‘Ì”Ì†Ì“Í‹Ì”Ì•Ì‚Í›Ì”Í‹Ì›ÌªÌ§Ì¯Ì­ÌŸÌ«Ì­Ì©Ì™ÍˆÌ§Ì¯Ì±Ì®Ì¬ÌÌ Ì±Í•ÌÍ–Ì¤Ì—ÍÌ¼Ì–Ì²Ì¢Í"]
                let output = ""
                for (let i = 0; i < count; i++) {
                    output += corrupt[Math.floor(Math.random() * corrupt.length)]
                }
                return output
            }


            function getMatchesFragment(regex, str, dialogueI) {
                let matches = []
                for (const match of str.matchAll(regex)) {
                    matches.push({
                        match: match[0],
                        index: match["index"],
                        dialogueIdx: dialogueI
                    })
                };
                return matches
            }


            function replaceElement(array, target, replacement) {
                return array.map(obj => {
                    if (target == obj["match"]) {
                        return { ...obj, match: replacement }; // Replace 'name' property
                    }
                    return obj;
                });
            }


            function updateFragments() {
                const fragmentsElem = document.getElementById("fragments")
                fragmentsElem.innerHTML = toReplace.map(fragment => {
                    return `
<span class="fragment stylized-button">${fragment}</span>`
                }).join("")

                const fragmentsArr = [...document.getElementsByClassName("fragment")]
                changeFragmentsBGColor(fragmentsArr)
                
                fragmentsArr.forEach(element => {
                    element.addEventListener("click", onFragmentClick)
                });
            }


            function changeFragmentsBGColor(fragmentsArr) {
                const colors = ['#2C3E50', '#34495E', '#16A085', '#27AE60', '#2980B9', '#8E44AD', '#C0392B', '#D35400', '#F39C12', '#7F8C8D']
                fragmentsArr.forEach(element => {
                    const randomColor = colors[Math.floor(Math.random() * colors.length)]
                    element.style.backgroundColor = randomColor
                });
            }


            function updateInput() {
                dialogues.forEach(element => {
                    input = input.replace(element["original"], element["match"])
                });
            }


            //for AI message manipulation
            //display the manipulated AI message
            //hide the original AI message
            function updateAIMes() {
                if (toCut) {
                    toCut = false
                    triggerSlash(`/sendas name="{{char}}" ${input} |
/sendas name="{{char}}" <details><summary>Original</summary>
${origInput}
</details> |
/cut {{lastMessageId}} |
/hide {{lastMessageId}}
                    `)
                }
            }
        })
    </script>
</body>

</html>
```