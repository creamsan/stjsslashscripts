{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            width: 100%;
            margin: 0;
        }

        #main_cont {
            margin: 0 auto;
            width: 750px;
            height: 450px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            padding: 5px;
            background-image: url("https://wallpaperaccess.com/full/1155079.jpg");
            color: white;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 3px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }

        .move {
            visibility: hidden;
        }

        #p1RaiseInput,
        #p2RaiseInput {
            width: 50px;
            visibility: hidden;
        }

        .cardImg {
            width: 100px;
        }

        #players {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 200px;
            padding: 5px;
        }

        #exchange {
            width: 550px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 10px;
        }

        #cards,
        #aiCards {
            display: flex;
            justify-content: center;
            align-items: end;
            height: 200px;
            display: flex;
            gap: 5px;
        }

        #exchangeBtn {
            margin: 0 auto;
            width: 50%;
            visibility: hidden;
            background-color: rgb(22, 152, 203);
        }

        .move {
            width: 100px;
        }

        #p1Check {
            background-color: rgb(22, 152, 203);
        }

        #p1Call {
            background-color: rgb(22, 152, 203);
        }

        #p1Raise {
            background-color: rgb(36, 162, 66);
        }

        #p1Fold {
            background-color: rgb(202, 33, 33);
        }

        #output {
            font-weight: bold;
            font-size: 1.3em;
        }

        input[type="text"] {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background-color: #1e1e1e;
            color: #ffffff;
            width: 250px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s, color 0.3s;
        }

        input[type="text"]::placeholder {
            color: #888;
        }

        input[type="text"]:focus {
            outline: none;
            background-color: #2e2e2e;
            color: #ffffff;
        }

        #continueBtn {
            visibility: hidden;
            background-color: rgb(22, 152, 203);
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont">
        <div id="players">
            <div style="display: flex;gap: 3px;flex-direction: column;">
                <div><button class="move stylized-button" id="p1Check">Check</button></div>
                <div><button class="move stylized-button" id="p1Call">Call</button></div>
                <div style="display: flex;gap: 3px;justify-content: center;"><button class="move stylized-button"
                        id="p1Raise">Raise</button><input id="p1RaiseInput" type="text" value="10"><span
                        id="p1MaxRaise"></span></div>
                <div><button class="move stylized-button" id="p1Fold">Fold</button></div>
            </div>
            <div id="output">It's a bug. Check the console.</div>
            <button class="stylized-button" id="continueBtn">Continue <i class="fa-solid fa-paper-plane"></i></button>
        </div>
        <div id="exchange">
            <div id="aiCards"></div>
            <div id="cards"></div>
            <button id="exchangeBtn" class="stylized-button">Exchange <i class="fa-solid fa-paper-plane"></i></button>
        </div>
    </div>

    <script>
        const INITIAL_BANK = 100
        const ANTE = 10

        class Deck {
            static allCards = [
                'AS', '2S', '3S', '4S', '5S', '6S', '7S', '8S', '9S', 'TS', 'JS', 'QS', 'KS',
                'AC', '2C', '3C', '4C', '5C', '6C', '7C', '8C', '9C', 'TC', 'JC', 'QC', 'KC',
                'AD', '2D', '3D', '4D', '5D', '6D', '7D', '8D', '9D', 'TD', 'JD', 'QD', 'KD',
                'AH', '2H', '3H', '4H', '5H', '6H', '7H', '8H', '9H', 'TH', 'JH', 'QH', 'KH'
            ]

            #cards

            static fromJSON(json) {
                const data = JSON.parse(json)
                return new Deck(data.cards)
            }

            toJSON() {
                return {
                    cards: this.#cards
                }
            }

            constructor(cards = [...Deck.allCards]) {
                this.#cards = cards
            }

            get cards() {
                return this.#cards
            }

            shuffle() {
                for (let i = this.#cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1)); // Random index
                    [this.#cards[i], this.#cards[j]] = [this.#cards[j], this.#cards[i]]; // Swap elements
                }
            }

            resetCards() {
                this.#cards = [...Deck.allCards]
            }

            getCard() {
                return this.#cards.pop()
            }
        }


        class Poker {
            static PHASE = {
                ASSIGN_DEALER: 0,
                PLACE_ANTE: 1,
                DEAL_CARDS: 2,
                PRE_EXCHANGE_BETS: 3,
                EXCHANGE: 4,
                POST_EXCHANGE_BETS: 5,
                SHOWDOWN: 6
            }

            get phase() {
                return this.#phase
            }

            static HANDS = {
                HIGH_CARD: 0,
                ONE_PAIR: 1,
                TWO_PAIR: 2,
                THREE_OF_A_KIND: 3,
                STRAIGHT: 4,
                FLUSH: 5,
                FULL_HOUSE: 6,
                FOUR_OF_A_KIND: 7,
                STRAIGHT_FLUSH: 8,
                ROYAL_FLUSH: 9
            }

            static MOVES = {
                CHECK: 0,
                CALL: 1,
                RAISE: 2,
                FOLD: 3
            }

            #firstP
            #secondP
            #deck
            #player1
            #player2
            #dealer
            #phase
            #pot
            #lastBet
            #lastBetter
            #ante
            #winner
            #roundWinner

            static fromJSON(json) {
                const data = json
                const deck = Deck.fromJSON(JSON.stringify(data.deck))
                const p1 = Player.fromJSON(JSON.stringify(data.player1))
                const p2 = Player.fromJSON(JSON.stringify(data.player2))
                return new Poker(data.firstP, data.secondP, deck, p1, p2, data.dealer, data.phase, data.pot, data.lastBet, data.lastBetter, data.ante, data.winner, data.roundWinner)
            }

            toJSON() {
                return {
                    firstP: this.#firstP === "" ? "" : this.#firstP === this.#player1 ? "{{user}}" : "{{char}}",
                    secondP: this.#secondP === "" ? "" : this.#secondP === this.#player1 ? "{{user}}" : "{{char}}",
                    deck: this.#deck.toJSON(),
                    player1: this.#player1.toJSON(),
                    player2: this.#player2.toJSON(),
                    dealer: this.#dealer === "" ? "" : this.#dealer === this.#player1 ? "{{user}}" : "{{char}}",
                    phase: this.#phase,
                    pot: this.#pot,
                    lastBet: this.#lastBet,
                    lastBetter: this.#lastBetter === "" ? "" : this.#lastBetter === this.#player1 ? "{{user}}" : "{{char}}",
                    ante: this.#ante,
                    winner: this.#winner === "" ? "" : this.winner === this.#player1 ? "{{user}}" : "{{char}}",
                    roundWinner: this.#roundWinner === "" ? "" : {
                        player: this.#roundWinner.player === this.#player1 ? "{{user}}" : "{{char}}",
                        hand: this.#roundWinner.hand
                    }
                }
            }

            constructor(firstP = "", secondP = "", deck = new Deck(), player1 = new Player("{{user}}", INITIAL_BANK), player2 = new Player("{{char}}", INITIAL_BANK), dealer = "", phase = -1, pot = 0, lastBet = 0, lastBetter = "", ante = ANTE, winner = "", roundWinner = "") {
                this.#player1 = player1
                this.#player2 = player2
                this.#firstP = firstP === "" ? "" : firstP === "{{user}}" ? this.#player1 : this.#player2
                this.#secondP = secondP === "" ? "" : secondP === "{{user}}" ? this.#player1 : this.#player2
                this.#deck = deck
                this.#dealer = dealer === "" ? "" : dealer === "{{user}}" ? this.#player1 : this.#player2
                this.#phase = phase
                this.#pot = pot
                this.#lastBet = lastBet
                this.#lastBetter = lastBetter === "" ? "" : lastBetter === "{{user}}" ? this.#player1 : this.#player2
                this.#ante = ante
                this.#winner = winner === "" ? "" : winner === "{{user}}" ? this.#player1 : this.#player2
                this.#roundWinner = roundWinner === "" ? "" : roundWinner === "{{user}}" ? this.#player1 : this.#player2
            }

            get pot() {
                return this.#pot
            }

            get roundWinner() {
                return this.#roundWinner
            }

            get winner() {
                return this.#winner
            }

            get ante() {
                return this.#ante
            }

            get deck() {
                return this.#deck
            }

            get player1() {
                return this.#player1
            }

            get player2() {
                return this.#player2
            }

            get dealer() {
                return this.#dealer
            }

            get lastBet() {
                return this.#lastBet
            }

            get lastBetter() {
                return this.#lastBetter
            }

            nextPhase() {
                this.#phase++
                if (this.#phase > Object.keys(Poker.PHASE).length - 1) {
                    this.#phase = 0
                }

                switch (this.#phase) {
                    case Poker.PHASE.ASSIGN_DEALER:
                        this.#deck.resetCards()
                        this.#deck.shuffle()
                        this.#roundWinner = ""
                        this.#player1.emptyHand()
                        this.player2.emptyHand()
                        this.#dealer = this.#dealer === this.#player1 ? this.#player2 : this.#player1
                        this.#firstP = this.#dealer
                        this.#secondP = this.#dealer === this.#player1 ? this.#player2 : this.#player1
                        break
                    case Poker.PHASE.PLACE_ANTE:
                        this.playerMove(this.#firstP, Poker.MOVES.CALL, this.#ante)
                        this.playerMove(this.#secondP, Poker.MOVES.CALL, this.#ante)
                        break
                    case Poker.PHASE.DEAL_CARDS:
                        for (let i = 0; i < 5; i++) {
                            this.#firstP.addCardToHand(this.#deck.getCard())
                            this.#secondP.addCardToHand(this.#deck.getCard())
                        }
                        break
                    case Poker.PHASE.PRE_EXCHANGE_BETS:
                        this.#lastBet = 0
                        this.#lastBetter = this.#firstP
                        break
                    case Poker.PHASE.EXCHANGE:

                        break
                    case Poker.PHASE.POST_EXCHANGE_BETS:
                        this.#lastBet = 0
                        this.#lastBetter = this.#firstP
                        break
                    case Poker.PHASE.SHOWDOWN:
                        let firstPHand = this.evaluateHand(this.#firstP.hand)
                        let secondPHand = this.evaluateHand(this.#secondP.hand)

                        if (firstPHand > secondPHand) {
                            this.#roundWinner = {
                                player: this.#firstP,
                                hand: this.descriptiveHand(firstPHand)
                            }
                            this.#firstP.earn(this.#pot)
                        } else if (firstPHand < secondPHand) {
                            this.#roundWinner = {
                                player: this.#secondP,
                                hand: this.descriptiveHand(secondPHand)
                            }
                            this.#secondP.earn(this.#pot)
                        } else {
                            let tieWin = this.getTiedHandWinner(this.#firstP.hand, this.#secondP.hand, firstPHand)
                            if (tieWin === 1) {
                                this.#roundWinner = {
                                    player: this.#firstP,
                                    hand: this.descriptiveHand(firstPHand)
                                }
                                this.#firstP.earn(this.#pot)
                            }
                            else if (tieWin === 2) {
                                this.#roundWinner = {
                                    player: this.#secondP,
                                    hand: this.descriptiveHand(secondPHand)
                                }
                                this.#secondP.earn(this.#pot)
                            }
                            else {
                                this.#roundWinner = {
                                    player: "",
                                    hand: "Tie"
                                }
                                this.#firstP.earn(this.#pot / 2)
                                this.#secondP.earn(this.#pot)
                            }
                        }

                        this.#pot = 0
                        if (this.#player1.bank <= 0) {
                            this.#winner = this.#player2
                        }
                        else if (this.#player2.bank <= 0) {
                            this.#winner = this.#player1
                        }
                        break
                    default: console.error("Error on next poker phase")
                }
            }

            playerMove(player, move, bet = 0) {
                switch (this.#phase) {
                    case Poker.PHASE.ASSIGN_DEALER:
                    case Poker.PHASE.DEAL_CARDS:
                    case Poker.PHASE.SHOWDOWN:
                        console.error("Player move invalid. Can't make a move during this phase.")
                        return
                }
                switch (move) {
                    case Poker.MOVES.CHECK:

                        break
                    case Poker.MOVES.CALL:
                        player.bet(bet)
                        this.#pot += bet
                        this.#lastBet = bet
                        break
                    case Poker.MOVES.RAISE:
                        player.bet(bet)
                        this.#pot += bet
                        this.#lastBet = bet
                        this.#lastBetter = player
                        break
                    case Poker.MOVES.FOLD:
                        let winner = player === this.player1 ? this.player2 : this.player1
                        winner.earn(this.#pot)
                        this.#pot = 0
                        this.#phase = Poker.PHASE.SHOWDOWN
                        this.#roundWinner = {
                            player: winner,
                            hand: "Opponent folded"
                        }
                        break
                }
            }


            getTiedHandWinner(hand1, hand2, handType) {
                // hand1 and hand2 are arrays of card objects: [{rank: '10', suit: 'hearts'}, ...]
                // handType is a string: 'pair', 'two-pair', 'three-of-a-kind', 'straight', 'flush', 'full-house', 'four-of-a-kind', 'straight-flush'

                let h1 = hand1.map(card => {
                    let firstChar = card.match(/^./i)[0]
                    return {
                        rank: firstChar
                    }
                })
                let h2 = hand2.map(card => {
                    let firstChar = card.match(/^./i)[0]
                    return {
                        rank: firstChar
                    }
                })

                const rankValues = {
                    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
                    'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
                };

                const getRankValue = (rank) => rankValues[rank];

                const getRankCounts = (hand) => {
                    const counts = {};
                    hand.forEach(card => {
                        counts[card.rank] = (counts[card.rank] || 0) + 1;
                    });
                    return counts;
                };

                const getSortedRanks = (hand, counts) => {
                    // Sort by count (descending), then by rank value (descending)
                    return Object.keys(counts).sort((a, b) => {
                        if (counts[b] !== counts[a]) return counts[b] - counts[a];
                        return getRankValue(b) - getRankValue(a);
                    }).map(getRankValue);
                };

                const getKickers = (hand, excludeRanks) => {
                    return hand
                        .map(card => getRankValue(card.rank))
                        .filter(rank => !excludeRanks.includes(rank))
                        .sort((a, b) => b - a);
                };

                switch (handType) {
                    case Poker.HANDS.ONE_PAIR:
                    case Poker.HANDS.THREE_OF_A_KIND:
                    case Poker.HANDS.FOUR_OF_A_KIND: {
                        const counts1 = getRankCounts(h1);
                        const counts2 = getRankCounts(h2);
                        const sorted1 = getSortedRanks(h1, counts1);
                        const sorted2 = getSortedRanks(h2, counts2);

                        // Compare the main rank (pair/three/four)
                        if (sorted1[0] > sorted2[0]) return 1;
                        if (sorted1[0] < sorted2[0]) return 2;

                        // Compare kickers
                        for (let i = 1; i < sorted1.length; i++) {
                            if (sorted1[i] > sorted2[i]) return 1;
                            if (sorted1[i] < sorted2[i]) return 2;
                        }
                        return 0; // tie
                    }

                    case Poker.HANDS.TWO_PAIR: {
                        const counts1 = getRankCounts(h1);
                        const counts2 = getRankCounts(h2);
                        const sorted1 = getSortedRanks(h1, counts1);
                        const sorted2 = getSortedRanks(h2, counts2);

                        // Compare high pair
                        if (sorted1[0] > sorted2[0]) return 1;
                        if (sorted1[0] < sorted2[0]) return 2;

                        // Compare low pair
                        if (sorted1[1] > sorted2[1]) return 1;
                        if (sorted1[1] < sorted2[1]) return 2;

                        // Compare kicker
                        if (sorted1[2] > sorted2[2]) return 1;
                        if (sorted1[2] < sorted2[2]) return 2;

                        return 0; // tie
                    }

                    case Poker.HANDS.FULL_HOUSE: {
                        const counts1 = getRankCounts(h1);
                        const counts2 = getRankCounts(h2);
                        const sorted1 = getSortedRanks(h1, counts1);
                        const sorted2 = getSortedRanks(h2, counts2);

                        // Compare three-of-a-kind first
                        if (sorted1[0] > sorted2[0]) return 1;
                        if (sorted1[0] < sorted2[0]) return 2;

                        // Compare pair
                        if (sorted1[1] > sorted2[1]) return 1;
                        if (sorted1[1] < sorted2[1]) return 2;

                        return 0; // tie
                    }

                    case Poker.HANDS.STRAIGHT:
                    case Poker.HANDS.STRAIGHT_FLUSH: {
                        const ranks1 = h1.map(card => getRankValue(card.rank)).sort((a, b) => b - a);
                        const ranks2 = h2.map(card => getRankValue(card.rank)).sort((a, b) => b - a);

                        // Check for A-2-3-4-5 (wheel/5-high straight)
                        const isWheel1 = ranks1[0] === 14 && ranks1[1] === 5;
                        const isWheel2 = ranks2[0] === 14 && ranks2[1] === 5;

                        const high1 = isWheel1 ? 5 : ranks1[0];
                        const high2 = isWheel2 ? 5 : ranks2[0];

                        if (high1 > high2) return 1;
                        if (high1 < high2) return 2;
                        return 0; // tie
                    }

                    case Poker.HANDS.FLUSH:
                    case Poker.HANDS.HIGH_CARD: {
                        const ranks1 = h1.map(card => getRankValue(card.rank)).sort((a, b) => b - a);
                        const ranks2 = h2.map(card => getRankValue(card.rank)).sort((a, b) => b - a);

                        // Compare each card from highest to lowest
                        for (let i = 0; i < ranks1.length; i++) {
                            if (ranks1[i] > ranks2[i]) return 1;
                            if (ranks1[i] < ranks2[i]) return 2;
                        }
                        return 0; // tie
                    }

                    default:
                        throw new Error(`Unknown hand type: ${handType}`);
                }
            }

            evaluateHand(cards) {
                const values = cards.map(card => card[0]);
                const suits = cards.map(card => card[1]);

                const valueCounts = {};
                values.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });

                const uniqueValues = Object.keys(valueCounts);
                const counts = Object.values(valueCounts).sort((a, b) => b - a);

                const isFlush = new Set(suits).size === 1;
                const isStraight = uniqueValues.length === 5 && (Math.max(...uniqueValues.map(v => "23456789TJQKA".indexOf(v))) - Math.min(...uniqueValues.map(v => "23456789TJQKA".indexOf(v))) === 4);
                const royalFlushValues = ['A', 'K', 'Q', 'J', 'T'];
                const hasRoyalFlush = royalFlushValues.every(value => uniqueValues.includes(value)) && isFlush;

                if (hasRoyalFlush) return Poker.HANDS.ROYAL_FLUSH
                if (isFlush && isStraight) return Poker.HANDS.STRAIGHT_FLUSH
                if (counts[0] === 4) return Poker.HANDS.FOUR_OF_A_KIND
                if (counts[0] === 3 && counts[1] === 2) return Poker.HANDS.FULL_HOUSE
                if (isFlush) return Poker.HANDS.FLUSH
                if (isStraight) return Poker.HANDS.STRAIGHT
                if (counts[0] === 3) return Poker.HANDS.THREE_OF_A_KIND
                if (counts[0] === 2 && counts[1] === 2) return Poker.HANDS.TWO_PAIR
                if (counts[0] === 2) return Poker.HANDS.ONE_PAIR
                return Poker.HANDS.HIGH_CARD
            }

            descriptiveHand(handEnum) {
                switch (handEnum) {
                    case Poker.HANDS.HIGH_CARD: return "High Card"
                    case Poker.HANDS.ONE_PAIR: return "One Pair"
                    case Poker.HANDS.TWO_PAIR: return "Two Pair"
                    case Poker.HANDS.THREE_OF_A_KIND: return "Three of a Kind"
                    case Poker.HANDS.STRAIGHT: return "Straight"
                    case Poker.HANDS.FLUSH: return "Flush"
                    case Poker.HANDS.FULL_HOUSE: return "Full House"
                    case Poker.HANDS.FOUR_OF_A_KIND: return "Four of a Kind"
                    case Poker.HANDS.STRAIGHT_FLUSH: return "Straight Flush"
                    case Poker.HANDS.ROYAL_FLUSH: return "Royal Flush"
                }
            }
        }


        class Player {
            #name
            #hand
            #bank
            #clothes

            static fromJSON(json) {
                const data = JSON.parse(json)
                return new Player(data.name, data.bank, data.clothes, data.hand)
            }

            toJSON() {
                return {
                    name: this.#name,
                    bank: this.#bank,
                    hand: this.#hand,
                    clothes: this.#clothes
                }
            }

            constructor(name, bank, clothes = {}, hand = []) {
                this.#name = name
                this.#bank = bank
                this.#hand = hand
                this.#clothes = clothes
            }

            addCardToHand(card) {
                if (this.#hand.length === 5) return
                this.#hand.push(card)
            }

            earn(amount) {
                this.#bank += amount
            }

            discard(cards) {
                this.#hand = this.#hand.filter(c => !cards.includes(c))
            }

            bet(amount) {
                this.#bank -= amount
            }

            emptyHand() {
                this.#hand = []
            }

            get clothes() {
                return this.#clothes
            }

            set clothes(clothes) {
                this.#clothes = clothes
            }

            get name() {
                return this.#name
            }

            get hand() {
                return this.#hand
            }

            get bank() {
                return this.#bank
            }
        }


        const main_cont = document.getElementById("main_cont")


        //ai side
        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                error.style.display = "none"
            })
        }


        //ai side
        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipes.length - 1]
            const regexInput = /<move>[\S\s]+?<\/move>/i
            input = regexInput.test(input) ? (input.match(regexInput))[0] : ""
        }


        let toJB
        let gameOver
        let swiped
        let toCut
        let userMesEdited
        let chatData
        let cooldown
        let expectingOutput
        let pause = false
        async function loadChatData() {
            chatData = getVariables().chatData == null ? null : JSON.parse(getVariables().chatData)
            if (chatData == null) {
                await triggerSlash(`/setvar key=chatData {}`)
                chatData = {}
                toJB = ""
                gameOver = false
                swiped = false
                toCut = true
                userMesEdited = false
                cooldown = 0
                expectingOutput = false
                poker = new Poker()
                p1 = poker.player1
                p2 = poker.player2
                nextPokerPhase()
            }
            else {
                toJB = chatData.toJB
                gameOver = chatData.gameOver
                swiped = chatData.swiped
                toCut = chatData.toCut
                expectingOutput = chatData.expectingOutput
                userMesEdited = false
                cooldown = chatData.cooldown
                poker = Poker.fromJSON(chatData.pokerData)
                p1 = poker.player1
                p2 = poker.player2
            }
        }


        async function saveData() {
            chatData.gameOver = gameOver
            chatData.swiped = swiped
            chatData.toCut = toCut
            chatData.userMesEdited = userMesEdited
            chatData.toJB = toJB
            chatData.expectingOutput = expectingOutput
            chatData.cooldown = cooldown
            chatData.pokerData = poker.toJSON()
            await triggerSlash(`/setvar key=chatData ${JSON.stringify(chatData)}`)
        }


        function verifyClothes() {
            const regexUserClothes = /(?<=<clothes>\s*{{user}}:\s+)[\S\s]+?(?=\s+Opponent)/i
            const regexCharClothes = /(?<=<clothes>[\S\s]+Opponent:\s+)[\S\s]+?(?=\s+<\/clothes>)/i
            const firstMes = chatMessages.swipes[chatMessages.swipes.length - 1]

            if (regexUserClothes.test(firstMes) && regexCharClothes.test(firstMes)) {
                let clothesObj = {}
                let p1clothes = JSON.parse(firstMes.match(regexUserClothes)[0])
                let increment = INITIAL_BANK / p1clothes.length
                p1clothes.forEach((clothing, i) => {
                    clothesObj[clothing] = i * increment
                });
                p1.clothes = clothesObj

                clothesObj = {}
                let p2clothes = JSON.parse(firstMes.match(regexCharClothes)[0])
                increment = INITIAL_BANK / p2clothes.length
                p2clothes.forEach((clothing, i) => {
                    clothesObj[clothing] = i * increment
                })
                p2.clothes = clothesObj

                return true
            }
            else {
                toastr.error("Wrong clothes format in the intro.")
                return false
            }
        }


        //ai side
        function verifyInputs(toVerify) {
            const mesId = chatMessages.message_id

            if (mesId === 0 && verifyClothes() === false) {
                return false
            }

            if (gameOver) {
                main_cont.parentNode.removeChild(main_cont)
                return false
            }

            if (mesId != 0 && input == "" && expectingOutput) {
                main_cont.style.display = "none"
                error.style.display = "flex"
                return false
            }

            for (const element of toVerify) {
                if (mesId != 0 && (element == "" || correctFormat(element) === false) && expectingOutput) {
                    main_cont.style.display = "none"
                    error.style.display = "flex"
                    return false
                }
            }

            if (mesId === 0 || expectingOutput === false) {
                pause = true
                main_cont.style.display = "none"
                error.style.display = "none"
            }

            return true
        }


        const regexBet = /bet:\s*\$?\d+/i
        const regexDiscard = /discard:(\s*[2-9tajkq][schd],?){0,5}/i
        function correctFormat(aiInput) {
            return regexBet.test(aiInput) || regexDiscard.test(aiInput)
        }


        const p1Check = document.getElementById("p1Check")
        const p1Call = document.getElementById("p1Call")
        const p1Raise = document.getElementById("p1Raise")
        const p1RaiseInput = document.getElementById("p1RaiseInput")
        const p1MaxRaise = document.getElementById("p1MaxRaise")
        const p1Fold = document.getElementById("p1Fold")
        const cards = document.getElementById("cards")
        const aiCards = document.getElementById("aiCards")
        const exchangeBtn = document.getElementById("exchangeBtn")
        const output = document.getElementById("output")
        const continueBtn = document.getElementById("continueBtn")

        let poker
        let p1
        let p2
        const MOVES_AFTER_CHECK = ["Check", "Raise", "Fold"]
        const MOVES_AFTER_RAISE = ["Call", "Raise", "Fold"]
        const p1BtnsArr = [p1Check, p1Call, p1Raise, p1Fold, p1RaiseInput, p1MaxRaise]
        let p1ToExchange = []
        let p2ToExchange = []


        function nextPokerPhase(next = true) {
            if (next) poker.nextPhase()
            if (poker.winner != "") {
                showCardsToExchange(p1.hand)
                showAICards(p2.hand)
                gameOver = true
                output.innerText = "Game over."
                continueBtn.style.visibility = "visible"
                toJB += `- Last game showdown:
- Your hand: ${p2.hand} - ${poker.descriptiveHand(poker.evaluateHand(p2.hand))}
- {{user}}'s hand: ${p1.hand} - ${poker.descriptiveHand(poker.evaluateHand(p1.hand))}
- ${poker.roundWinner.player.name === "{{user}}" ? "You lost" : "You won"}
`
                continueBtn.style.visibility = "visible"
                return
            }
            //hideMoveBtns()
            switch (poker.phase) {
                case Poker.PHASE.ASSIGN_DEALER:
                    showAICards([])
                    showCardsToExchange([])
                    output.innerText = ""
                    nextPokerPhase()
                    break
                case Poker.PHASE.PLACE_ANTE:
                    showAICards([])
                    showCardsToExchange([])
                    nextPokerPhase()
                    break
                case Poker.PHASE.DEAL_CARDS:
                    showAICards(["NA", "NA", "NA", "NA", "NA"])
                    showCardsToExchange(p1.hand)
                    nextPokerPhase()
                    break
                case Poker.PHASE.PRE_EXCHANGE_BETS:
                    showAICards(["NA", "NA", "NA", "NA", "NA"])
                    showCardsToExchange(p1.hand)
                    exchangeBtn.style.visibility = "hidden"
                    if (poker.dealer.name === "{{user}}") {
                        //showAvailableBtns(MOVES_AFTER_CHECK, p2BtnsArr)
                        //tell ai to: check, raise, fold
                        aiMakeMove("first")
                    }
                    else {
                        showAvailableBtns(MOVES_AFTER_CHECK, p1BtnsArr)
                    }
                    updateStats()
                    break
                case Poker.PHASE.EXCHANGE:
                    exchangeBtn.style.visibility = "visible"
                    updateStats()
                    break
                case Poker.PHASE.POST_EXCHANGE_BETS:
                    showAICards(["NA", "NA", "NA", "NA", "NA"])
                    showCardsToExchange(p1.hand)
                    exchangeBtn.style.visibility = "hidden"
                    if (poker.dealer.name === "{{user}}") {
                        //showAvailableBtns(MOVES_AFTER_CHECK, p2BtnsArr)
                        //tell ai to: check raise, fold
                        aiMakeMove("first")
                    }
                    else {
                        showAvailableBtns(MOVES_AFTER_CHECK, p1BtnsArr)
                    }
                    updateStats()
                    break
                case Poker.PHASE.SHOWDOWN:
                    continueBtn.style.visibility = "visible"
                    showAICards(p2.hand)
                    updateStats()
                    toJB += `- Last game showdown:
- Your hand: ${p2.hand} - ${poker.descriptiveHand(poker.evaluateHand(p2.hand))}
- {{user}}'s hand: ${p1.hand} - ${poker.descriptiveHand(poker.evaluateHand(p1.hand))}
- ${poker.roundWinner.player.name === "{{user}}" ? "You lost" : "You won"}
`
            }
        }


        function updateStats() {
            let toAppend = ""
            if (poker.phase === Poker.PHASE.EXCHANGE) {
                toAppend = `<br>Opponent discarded ${p2ToExchange.length} cards.<br>Select the cards you want to exchange.`
            }
            else if (poker.phase === Poker.PHASE.SHOWDOWN) {
                toAppend = `<br>${poker.roundWinner.player.name === "{{user}}" ? "You won" : "You lost"}<br>Winning hand: ${poker.roundWinner.hand}`
            }
            output.innerHTML = `Pot: $${poker.pot}<br>Last bet: $${poker.lastBet}<br>Bank: $${poker.player1.bank}${toAppend}`
        }


        function getCardImgLink(card) {
            const uiCards = {
                'AS': "ace_of_spades",
                '2S': "2_of_spades",
                '3S': "3_of_spades",
                '4S': "4_of_spades",
                '5S': "5_of_spades",
                '6S': "6_of_spades",
                '7S': "7_of_spades",
                '8S': "8_of_spades",
                '9S': "9_of_spades",
                'TS': "10_of_spades",
                'JS': "jack_of_spades",
                'QS': "queen_of_spades",
                'KS': "king_of_spades",
                'AC': "ace_of_clubs",
                '2C': "2_of_clubs",
                '3C': "3_of_clubs",
                '4C': "4_of_clubs",
                '5C': "5_of_clubs",
                '6C': "6_of_clubs",
                '7C': "7_of_clubs",
                '8C': "8_of_clubs",
                '9C': "9_of_clubs",
                'TC': "10_of_clubs",
                'JC': "jack_of_clubs",
                'QC': "queen_of_clubs",
                'KC': "king_of_clubs",
                'AD': "ace_of_diamonds",
                '2D': "2_of_diamonds",
                '3D': "3_of_diamonds",
                '4D': "4_of_diamonds",
                '5D': "5_of_diamonds",
                '6D': "6_of_diamonds",
                '7D': "7_of_diamonds",
                '8D': "8_of_diamonds",
                '9D': "9_of_diamonds",
                'TD': "10_of_diamonds",
                'JD': "jack_of_diamonds",
                'QD': "queen_of_diamonds",
                'KD': "king_of_diamonds",
                'AH': "ace_of_hearts",
                '2H': "2_of_hearts",
                '3H': "3_of_hearts",
                '4H': "4_of_hearts",
                '5H': "5_of_hearts",
                '6H': "6_of_hearts",
                '7H': "7_of_hearts",
                '8H': "8_of_hearts",
                '9H': "9_of_hearts",
                'TH': "10_of_hearts",
                'JH': "jack_of_hearts",
                'QH': "queen_of_hearts",
                'KH': "king_of_hearts",
                'NA': "https://clipart-library.com/images/8cxrbGE6i.jpg"
            }
            return card !== "NA" ? `https://raw.githubusercontent.com/hayeah/playing-cards-assets/refs/heads/master/svg-cards/${uiCards[card]}.svg` : uiCards[card]
        }


        function showAICards(hand) {
            const toHtml = hand.map(card => {
                return `<img class="cardImg" src="${getCardImgLink(card)}" alt="${card}">`
            }).join('')
            aiCards.innerHTML = toHtml
        }


        function showCardsToExchange(hand) {
            const toHtml = hand.map(card => {
                return `<img class="cardImg" src="${getCardImgLink(card)}" alt="${card}">`
            }).join('')
            cards.innerHTML = toHtml

            const clickableCards = [...document.getElementsByClassName("cardImg")]
            clickableCards.forEach(element => {
                element.addEventListener("click", onCardUIClick)
            });
        }


        function onCardUIClick(e) {
            let card = e.target
            if (card.style.paddingBottom === "" || card.style.paddingBottom === "0px") {
                card.style.paddingBottom = "50px"
                p1ToExchange.push(card.alt)
            }
            else {
                card.style.paddingBottom = "0px"
                p1ToExchange = p1ToExchange.filter(c => card.alt !== c)
            }
        }


        function hideMoveBtns() {
            p1BtnsArr.forEach(element => {
                element.style.visibility = "hidden"
            });
        }


        function showAvailableBtns(moves, playerBtns) {
            let visible = []
            moves.forEach(move => {
                visible = [...visible, ...playerBtns.filter(btn => RegExp(move, "i").test(btn.id))]
            });
            visible.forEach(element => {
                element.style.visibility = "visible"
            });
            p1MaxRaise.innerText = "Max: " + p1.bank
        }


        function aiMakeMove(lastUserMove, userBet = 0) {
            if (pause) return
            const hand = poker.evaluateHand(poker.player2.hand)
            switch (lastUserMove) {
                case "first":
                    if (maxBet > 0) {
                        let raiseVal = maxBet
                        raiseVal = Math.min(p2.bank, raiseVal)
                        if (chatMessages.message_id != 0) toastr.info(`First -> Opponent raised the bet by ${raiseVal}`)
                        poker.playerMove(p2, Poker.MOVES.RAISE, raiseVal)
                        hideMoveBtns()
                        showAvailableBtns(MOVES_AFTER_RAISE, p1BtnsArr)
                        updateStats()
                    }
                    else {
                        poker.playerMove(p2, Poker.MOVES.CHECK)
                        hideMoveBtns()
                        if (poker.lastBetter === p2) {
                            nextPokerPhase()
                        }
                        else {
                            if (chatMessages.message_id != 0) toastr.info("First -> Opponent checked")
                            showAvailableBtns(MOVES_AFTER_CHECK, p1BtnsArr)
                            updateStats()
                        }
                    }
                    break
                case "check":
                    if (maxBet <= 0) {
                        poker.playerMove(p2, Poker.MOVES.CHECK)
                        hideMoveBtns()
                        if (poker.lastBetter === p2) {
                            nextPokerPhase()
                        }
                        else {
                            toastr.info("Check -> Opponent checked")
                            showAvailableBtns(MOVES_AFTER_CHECK, p1BtnsArr)
                            updateStats()
                        }
                    }
                    else {
                        let raiseVal = maxBet
                        raiseVal = Math.min(p2.bank, raiseVal)
                        toastr.info(`Check -> Opponent raised the bet by ${raiseVal}`)
                        poker.playerMove(p2, Poker.MOVES.RAISE, raiseVal)
                        hideMoveBtns()
                        showAvailableBtns(MOVES_AFTER_RAISE, p1BtnsArr)
                        updateStats()
                    }
                    break
                case "raise":
                    let toBet = maxBet - userBet
                    let toCall = "{{random:true, false}}" === "true" ? true : false
                    if (toCall === false && (maxBet === 0 || toBet < 0)) {
                        toastr.info("Raise -> Opponent folded")
                        poker.playerMove(p2, Poker.MOVES.FOLD)
                        hideMoveBtns()
                        updateStats()
                        continueBtn.style.visibility = "visible"
                        toJB += `- You folded.
`
                    }
                    else if (toBet <= 0 || maxBet === 0) {
                        toastr.info("Raise -> Opponent called")
                        let callVal = Math.min(p2.bank, poker.lastBet)
                        poker.playerMove(p2, Poker.MOVES.CALL, callVal)
                        hideMoveBtns()
                        nextPokerPhase()
                    }
                    else {
                        let raiseVal = Math.min(p2.bank, toBet)
                        poker.playerMove(p2, Poker.MOVES.RAISE, raiseVal)
                        toastr.info(`Raise -> Opponent raised the bet by ${raiseVal}`)
                        hideMoveBtns()
                        showAvailableBtns(MOVES_AFTER_RAISE, p1BtnsArr)
                        updateStats()
                    }
                    maxBet = toBet
                    break
            }
        }


        let maxBet
        function getAIMove(aiMove) {
            let toOutput = ""
            if (regexBet.test(aiMove)) {
                maxBet = Number.parseInt(aiMove.match(/(?<=bet:\s\$?)\d+/i)[0])
                maxBet = Math.min(p2.bank, maxBet)
            }
            if (regexDiscard.test(aiMove)) {
                p2ToExchange = Array.from(aiMove.matchAll(/\b[2-9ajqkt][schd]\b/gi), match => match[0])
            }
        }


        //main
        document.addEventListener("DOMContentLoaded", async function () {
            //init
            initError()

            await loadAIReply()
            await loadChatData()

            //regexes here
            const regexAIMove = /(?<=<move>\s+)[\S\s]+?(?=\s+<\/move>)/i
            const aiMove = regexAIMove.test(input) ? input.match(regexAIMove)[0] : ""

            const toVerify = [aiMove]
            if (verifyInputs(toVerify) === false) {
                await saveData()
                return
            }

            //buttons
            exchangeBtn.addEventListener("click", async function () {
                pause = true
                toJB += `- {{user}} discarded ${p1ToExchange.length} cards.
`
                //player
                p1.discard(p1ToExchange)
                for (let i = 0; i < p1ToExchange.length; i++) {
                    p1.addCardToHand(poker.deck.getCard())
                }
                p1ToExchange = []

                //ai
                p2.discard(p2ToExchange)
                for (let i = 0; i < p2ToExchange.length; i++) {
                    p2.addCardToHand(poker.deck.getCard())
                }
                p2ToExchange = []

                showCardsToExchange(p1.hand)
                exchangeBtn.style.visibility = "hidden"
                continueBtn.style.visibility = "visible"
                nextPokerPhase()
                await saveData()
                const a = "{{"
                const b = "input"
                const c = "}}"
                if (`${a + b + c}` == "") {
                    await triggerSlash(`/send ... |
                        /setinput {{noop}} | /trigger`)
                }
                else {
                    await triggerSlash(`/send ${a + b + c} |
                        /setinput {{noop}} | /trigger`)
                }
                main_cont.style.display = "none"
            })
            continueBtn.addEventListener("click", async function () {
                Object.keys(p1.clothes).forEach(c => {
                    if (p1.bank <= p1.clothes[c]) {
                        toJB += `- After the last game, {{user}} must take off his ${c}.
`
                        delete p1.clothes[c]
                    }
                });
                Object.keys(p2.clothes).forEach(c => {
                    if (p2.bank <= p2.clothes[c]) {
                        toJB += `- After the last game, you must take off your ${c}.
`
                        delete p2.clothes[c]
                    }
                });
                pause = true
                if (gameOver === false) nextPokerPhase()
                expectingOutput = false
                cooldown = 1
                await saveData()
                const a = "{{"
                const b = "input"
                const c = "}}"
                if (`${a + b + c}` == "") {
                    await triggerSlash(`/send ... |
                        /setinput {{noop}} | /trigger`)
                }
                else {
                    await triggerSlash(`/send ${a + b + c} |
                        /setinput {{noop}} | /trigger`)
                }
                main_cont.style.display = "none"
            })
            p1Call.addEventListener("click", function () {
                let callVal = Math.min(p1.bank, poker.lastBet)
                poker.playerMove(p1, Poker.MOVES.CALL, callVal)
                hideMoveBtns()
                //tell ai: which cards to discard
                nextPokerPhase()
            })
            p1Check.addEventListener("click", function () {
                poker.playerMove(p1, Poker.MOVES.CHECK)
                hideMoveBtns()
                if (poker.lastBetter === p1) {
                    //tell ai: which cards to discard????
                    nextPokerPhase()
                }
                else {
                    //showAvailableBtns(MOVES_AFTER_CHECK, p2BtnsArr)
                    //tell ai to: check, raise, fold
                    aiMakeMove("check")
                    updateStats()
                }
            })
            p1Raise.addEventListener("click", function () {
                let raiseVal = Number.parseInt(p1RaiseInput.value)
                raiseVal = Math.min(p1.bank, raiseVal)
                poker.playerMove(p1, Poker.MOVES.RAISE, raiseVal)
                hideMoveBtns()
                //showAvailableBtns(MOVES_AFTER_RAISE, p2BtnsArr)
                //tell ai to: call, raise, fold
                aiMakeMove("raise", raiseVal)
                updateStats()
            })
            p1Fold.addEventListener("click", function () {
                poker.playerMove(p1, Poker.MOVES.FOLD)
                hideMoveBtns()
                updateStats()
                //tell ai: it won after user folding
                toJB += `- {{user}} folded. You won.
`
                continueBtn.style.visibility = "visible"
            })

            //main func start here

            getAIMove(aiMove)
            nextPokerPhase(false)
            await saveData()
        })
    </script>
</body>

</html>
```