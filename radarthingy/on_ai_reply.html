{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/kaplay@4000.0.0-alpha.22/dist/kaplay.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            margin: 0;
            width: 100%;
            height: fit-content;
        }

        #main_cont {
            margin: 0 auto;
            width: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            margin-bottom: 5px;
            padding: 10px;
            color: #dcd1d1;
            background-image: url("https://t3.ftcdn.net/jpg/06/22/33/36/360_F_622333621_KwEUCiaY27QCk5Bi9ujUcQmuTBY5ljt3.jpg");
            background-position: center;
        }

        canvas {
            margin: 0 auto;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }

        #legPOI {
            background: rgb(229, 229, 80);
        }

        #legCache {
            background: rgb(80, 229, 199);
        }

        #legEnemy {
            background: rgb(224, 18, 39);
        }

        #legBase {
            background: rgb(32, 245, 22);
        }

        #legChar {
            background: rgb(237, 88, 237);
        }

        .entityLegend {
            width: 20px;
            height: 20px;
            border-radius: 50%
        }

        .legend {
            display: flex;
            gap: 10px;
        }

        #legUI {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #moveEntitiesBtn {
            background-color: darkcyan;
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont">
        <button id="moveEntitiesBtn" class="stylized-button">Move</button>
        <div id="legUI">
            <div class="legend">
                <div id="legChar" class="entityLegend"></div>
                <div>{{char}}</div>
            </div>
            <div class="legend">
                <div id="legPOI" class="entityLegend"></div>
                <div>POI</div>
            </div>
            <div class="legend">
                <div id="legCache" class="entityLegend"></div>
                <div>Cache</div>
            </div>
            <div class="legend">
                <div id="legEnemy" class="entityLegend"></div>
                <div>Enemy</div>
            </div>
            <div class="legend">
                <div id="legBase" class="entityLegend"></div>
                <div>{{user}}'s bunker entrance</div>
            </div>
        </div>
    </div>

    <script>
        const main_cont = document.getElementById("main_cont")
        const moveEntitiesBtn = document.getElementById("moveEntitiesBtn")
        const CANVAS_WIDTH = 514
        const CANVAS_HEIGHT = 485

        kaplay({
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
        })
        const game = document.querySelector("canvas")


        //ai side
        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                error.style.display = "none"
            })
        }


        //ai side
        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipes.length - 1]
            const regexInput = /<result>([\S\s](?!<result>))+?<\/result>/i
            input = regexInput.test(input) ? (input.match(regexInput))[0] : ""
        }


        let toJB = ""
        let gameOver
        let swiped
        let toCut
        let userMesEdited
        let expectingOutputOnId
        let chatData
        let chatDataHist
        let toUserProcess = {}
        let entitiesMove = false
        //ai side
        function loadChatData() {
            chatDataHist = getVariables().chatDataHist == null ? null : JSON.parse(getVariables().chatDataHist)
            chatData = chatDataHist == null ? null : chatDataHist[chatMessages.message_id - 1]
            if (chatData == null) {
                chatData = {}
                chatDataHist = {}
                gameOver = false
                swiped = false
                toCut = true
                expectingOutputOnId = -1
            }
            else {
                gameOver = chatData.gameOver
                swiped = chatData.swiped
                toCut = chatData.toCut
                expectingOutputOnId = chatData.expectingOutputOnId
            }
        }


        //ai side
        async function saveData() {
            chatData.gameOver = gameOver
            chatData.swiped = swiped
            chatData.toCut = toCut
            chatData.userMesEdited = false
            saveEntities()
            chatData.toUserProcess = toUserProcess
            chatDataHist[chatMessages.message_id] = chatData
            await triggerSlash(`/setvar key=chatDataHist ${JSON.stringify(chatDataHist)}`)
        }


        function saveEntities() {
            const entities = get("entity")
            let entitiesToSave = []
            entities.forEach(entity => {
                const newEntry = {
                    posX: entity.pos.x,
                    posY: entity.pos.y,
                    tags: entity.tags
                }
                entitiesToSave.push(newEntry)
            });
            chatData.toUserProcess.savedEntities = entitiesToSave
        }


        //ai side
        function verifyInputs(toVerify) {
            if (gameOver) {
                main_cont.parentNode.removeChild(main_cont)
                return false
            }

            const mesId = chatMessages.message_id

            if (expectingOutputOnId === mesId && input == "") {
                main_cont.style.display = "none"
                error.style.display = "flex"
                return false
            }

            for (const element of toVerify) {
                if (expectingOutputOnId === mesId && element == "") {
                    main_cont.style.display = "none"
                    error.style.display = "flex"
                    return false
                }
            }

            if (mesId === 0 || expectingOutputOnId != mesId) {
                main_cont.style.display = "none"
                error.style.display = "none"
            }

            return true
        }


        const ENTITY_SPEED = 1000

        function newEntities() {
            //user
            add([
                sprite("entity"),
                anchor("center"),
                scale(0.1),
                area({
                    scale: 1,
                }),
                pos(CANVAS_WIDTH / 2, CANVAS_HEIGHT - 15),
                "entity",
                "user"
            ])

            //char
            add([
                sprite("entity"),
                scale(0.1),
                anchor("center"),
                area({
                    scale: 1.5,
                }),
                pos(rand(15, CANVAS_WIDTH - 15), 15),
                "entity",
                "char",
            ])

            //weapons cache
            let cacheCount = randi(3, 6)
            for (let i = 0; i < cacheCount; i++) {
                add([
                    sprite("entity"),
                    anchor("center"),
                    scale(0.1),
                    area({
                        scale: 1,
                    }),
                    pos(rand(35, CANVAS_WIDTH - 35), rand(35, CANVAS_HEIGHT - 35)),
                    "entity",
                    "cache"
                ])
            }

            //poi - loc, mystery
            let poiCount = randi(1, 6)
            for (let i = 0; i < poiCount; i++) {
                add([
                    sprite("entity"),
                    anchor("center"),
                    scale(0.1),
                    area({
                        scale: 1,
                    }),
                    pos(rand(35, CANVAS_WIDTH - 35), rand(35, CANVAS_HEIGHT - 35)),
                    "entity",
                    "poi"
                ])
            }

            //enemies
            let enemyCount = randi(10, 25)
            for (let i = 0; i < enemyCount; i++) {
                const enemy = add([
                    sprite("entity"),
                    anchor("center"),
                    scale(0.1),
                    area({
                        scale: 1,
                    }),
                    pos(rand(15, CANVAS_WIDTH - 15), rand(CANVAS_HEIGHT / 2 - 100, CANVAS_HEIGHT / 2 + 100)),
                    "entity",
                    "enemy"
                ])

                enemy.tag(getRandomEnemyType())
            }
        }


        function loadEntities() {
            const entitiesToLoad = chatData.savedEntities
            entitiesToLoad.forEach(entry => {
                let tags = entry.tags
                const entity = add([
                    sprite("entity"),
                    scale(0.1),
                    anchor("center"),
                    area({
                        scale: 1,
                    }),
                    pos(entry.posX, entry.posY),
                ])
                entity.tag(tags)
            });
        }


        //514x485
        function initCanvas() {
            //background
            loadSprite("bg", "https://files.catbox.moe/17ru8j.jpg")
            add([
                sprite("bg", {
                    tiled: true,
                }),
                z(-1),
                scale(0.75),
                pos(-30, -15)
            ])

            //entities
            loadShader("blinking",
                null,
                //amp * sin(freq * u_time + start)
                `uniform float u_time;
                uniform vec4 u_color;
                vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {
                    float blink = sin(5.0 * u_time);
                    return def_frag() * vec4(1.0, 1.0, 1.0, blink <= 0.2 ? 1.0 : 0.0);
                }`
            )
            
            loadSprite("entity", "https://files.catbox.moe/astm2u.png")

            if (chatMessages.message_id === 0) {
                newEntities()
            }
            else {
                loadEntities()
            }


            //comp entities
            const user = get("user")[0]
            user.add([
                color(32, 245, 22),
            ])

            const char = get("char")[0]
            char.add([
                shader("blinking", () => ({
                    u_time: time(),
                })),
                color(237, 88, 237),
            ])
            char.area = {
                scale: 1.5,
            }

            function charMove(obj) {
                let steps = 500
                let moving = true

                return {
                    id: "charMove",
                    update() {
                        if(moving && entitiesMove && steps > 0) {
                            //get input from ai
                            //let step = vec2(direction.x * ENTITY_SPEED * dt(), direction.y * ENTITY_SPEED * dt())
                            obj.move(step)
                            steps -= 1 
                        }
                        else if(moving && entitiesMove && steps <= 0) {
                            moving = false
                        }
                    },
                }
            }

            const caches = get("cache")
            caches.forEach(cache => {
                cache.add([
                    color(80, 229, 199),
                ])
            });

            const pois = get("poi")
            pois.forEach(poi => {
                poi.add([
                    color(229, 229, 80),
                ])
            });

            const enemies = get("enemy")
            enemies.forEach(enemy => {
                enemy.add([
                    color(224, 18, 39),
                ])
            });

            //enemies
            const wanderSteps = [
                50, 100, 150, 200, 250, 300
            ]

            function wander(obj) {
                let steps = wanderSteps[Math.floor(Math.random() * wanderSteps.length)]
                let wandering = Math.random() > .5 ? true : false
                let direction = vec2(randi(-1, 2), randi(-1, 2)).unit()

                return {
                    id: "wander",
                    update() {
                        if (wandering && entitiesMove && steps > 0) {
                            let step = vec2(direction.x * ENTITY_SPEED * dt(), direction.y * ENTITY_SPEED * dt())
                            obj.move(step)
                            steps -= 1
                        }
                        else if(wandering && entitiesMove && steps <= 0){
                            wandering = false
                        }
                    },
                }
            }

            function track(obj) {
                let steps = 100
                let tracking = true
                let direction = get("char")[0].pos.sub(obj.pos)
                direction = direction.unit()

                return {
                    id: "track",
                    update() {
                        if (tracking && entitiesMove && steps > 0) {
                            let step = vec2(direction.x * ENTITY_SPEED * dt(), direction.y * ENTITY_SPEED * dt())
                            obj.move(step)
                            steps -= 1
                        }
                        else if(tracking && entitiesMove && steps <= 0) {
                            tracking = false
                        }
                    },
                }
            }

            const UNCLOAK_DIST = 60
            function cloak(obj) {
                return {
                    id: "cloak",
                    update() {
                        let dist = get("char")[0].pos.dist(obj.pos)
                        if (dist >= UNCLOAK_DIST) {
                            obj.opacity = 0
                        }
                        else {
                            obj.opacity = UNCLOAK_DIST / dist
                        }
                    },
                }
            }

            //enemy special props
            const mimics = get("mimic")
            mimics.forEach(mimic => {
                mimic.color = rgb(80, 229, 199)
            });

            const shamblers = get("shambler")
            shamblers.forEach(shambler => {
                shambler.add([
                    wander(shambler)
                ])
            });

            const trackers = get("tracker")
            trackers.forEach(tracker => {
                tracker.add([
                    track(tracker)
                ])
            });

            const invisibles = get("invisible")
            invisibles.forEach(invisible => {
                invisible.add([
                    cloak(invisible)
                ])
            })

            const brutes = get("brute")
            brutes.forEach(brute => {
                brute.scale = vec2(0.22)
            });

            onCollide("char", "enemy", (char, enemy) => {
                console.log("AAAAh")
            })

            onCollide("char", "poi", (char, poi) => {
                console.log("interedatstng")
            })

            onCollide("char", "cache", (char, cache) => {
                console.log("weapons ammo")
            })

            onCollide("char", "user", (char, user) => {
                console.log("finally")
            })

            onKeyDown("left", () => {
                get("char")[0].move(vec2(-1 * ENTITY_SPEED * 2 * dt(), 0))
            })
            onKeyDown("right", () => {
                get("char")[0].move(vec2(1 * ENTITY_SPEED * 2 * dt(), 0))
            })
            onKeyDown("up", () => {
                get("char")[0].move(vec2(0, -1 * ENTITY_SPEED * 2 * dt()))
            })
            onKeyDown("down", () => {
                get("char")[0].move(vec2(0, 1 * ENTITY_SPEED * 2 * dt()))
            })
        }


        const enemyTypes = [
            "stationary",
            "stationary",
            "stationary",
            "stationary",
            "stationary",
            "mimic",
            "shambler",
            "shambler",
            "shambler",
            "tracker",
            "invisible",
            "invisible",
            "brute"
        ]
        function getRandomEnemyType() {
            let specialCount = [1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 3]
            specialCount = specialCount[Math.floor(Math.random() * specialCount.length)]
            let outputArr = []
            for (let i = 0; i < specialCount; i++) {
                outputArr.push(enemyTypes[Math.floor(Math.random() * enemyTypes.length)])
            }
            //mimic - only 1
            //conflicts: shambler, tracker, stationary
            if (outputArr.indexOf("mimic") != -1) {
                outputArr = outputArr.filter(e => e === "mimic")
            }
            else if (outputArr.indexOf("tracker") != -1) {
                outputArr = outputArr.filter(e => e !== "shambler")
                    .filter(e => e !== "stationary")
            }
            else if (outputArr.indexOf("shambler") != -1) {
                outputArr = outputArr.filter(e => e !== "tracker")
                    .filter(e => e !== "stationary")
            }
            else if (outputArr.indexOf("stationary") != -1) {
                outputArr = outputArr.filter(e => e !== "tracker")
                    .filter(e => e !== "shambler")
            }
            outputArr = [...new Set(outputArr)]
            return outputArr
        }


        //main
        document.addEventListener("DOMContentLoaded", async function () {
            //ai
            initError()
            await loadAIReply()

            //ai user
            loadChatData()

            //ai
            //regexes here
            // const regexVar = /regex/i
            // const toVer = regexVar.test(input) ? input.match(regexVar)[0] : ""

            // const toVerify = []
            // if (verifyInputs(toVerify) === false) {
            //     await saveData()
            //     return
            // }

            //user
            // if (await handleUserMesEdit()) return

            //user
            // await loadChatMessages()

            //main func start here

            //initCanvas()

            moveEntitiesBtn.addEventListener("click", function() {
                entitiesMove = true
            })


            //ai
            prepToUserProcess()
            // updateJB()
            // saveData()
            document.querySelector("body").style.height = "fit-content"
        })


        //ai side
        function prepToUserProcess() {
            //process stuff to be updated on user side

        }


        //ai side
        async function updateJB() {
            await insertOrAssignVariables({ jbout: toJB })
            toJB = ""
        }
    </script>
</body>

</html>
```