{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- <script src="https://unpkg.com/kaplay@4000.0.0-alpha.22/dist/kaplay.js"></script> -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            margin: 0;
            width: 100%;
            height: fit-content;
        }

        #main_cont {
            margin: 0 auto;
            width: fit-content;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(226, 229, 247);
            padding: 5px
        }

        canvas {
            margin: 0 auto;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 3px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }

        .title {
            text-anchor: middle;
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont">
        <div id="graph"></div>
    </div>

    <script>
        const main_cont = document.getElementById("main_cont")


        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                error.style.display = "none"
            })
        }


        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipe_id]
            const regexInput = /<graph>([\S\s](?!<graph>))+?<\/graph>/i
            input = regexInput.test(input) ? (input.match(regexInput))[0] : ""
        }


        function verifyInputs(toVerify) {
            for (const element of toVerify) {
                if (element == "") {
                    main_cont.style.display = "none"
                    error.style.display = "flex"
                    return false
                }
            }

            return true
        }


        //main
        document.addEventListener("DOMContentLoaded", async function () {
            // initError()
            // await loadAIReply()

            //intro handler - for multi intro cards
            // if (chatMessages.message_id === 0) {

            // }

            //regexes here
            const regexVar = /regex/i
            const toVer = regexVar.test(input) ? input.match(regexVar)[0] : ""
            const graph = "network graph"
            const title = "Penis length"
            const data = `Nodes:
id,name
1,Left Striped Sock (Leader)
2,Right Polka Dot Sock (Traitor)
3,Lonely Ankle Sock (Outcast)
4,The Washing Machine (Villain)
5,Dryer (Chaos Agent)
6,Cum Sock
Links:
source,target
1,2
2,4
3,5
4,5
2,3
6,1
6,2
6,3`

            const toVerify = []
            if (verifyInputs(toVerify) === false) {
                await saveData()
                return
            }

            //main func start here
            try {
                switch (graph) {
                    case "heatmap":
                        drawHeatmap(data, title)
                        break
                    case "scatter plot":
                        drawScatterPlot(data, title)
                        break
                    case "barplot":
                        drawBarPlot(data, title)
                        break
                    case "pie chart":
                        drawPieChart(data, title)
                        break
                    case "line chart":
                        drawLineChart(data, title)
                        break
                    case "network graph":
                        drawNetwork(data, title)
                        break
                    case "colored bubble plot":
                        drawColoredBubblePlot(data, title)
                        break
                    case "radar chart":
                        drawRadarChart(data, title)
                        break
                    default:
                        console.error("Error on selecting chart")
                }
            }
            catch (e) {
                console.error("Error on generating graph: " + e)
                main_cont.style.display = "none"
                error.style.display = "flex"
            }
        })


        function csvToJson(csv) {
            const lines = csv.split('\n');
            const headers = lines[0].split(',');
            const jsonResult = [];

            for (let i = 1; i < lines.length; i++) {
                const currentLine = lines[i].split(',');
                const jsonObject = {};

                headers.forEach((header, index) => {
                    if (isNaN(currentLine[index])) {
                        jsonObject[header] = currentLine[index]
                    }
                    else {
                        jsonObject[header] = Number.isInteger(currentLine[index]) ? parseInt(currentLine[index]) : parseFloat(currentLine[index])
                    }
                });

                jsonResult.push(jsonObject);
            }
            return jsonResult;
        }


        function csvToJsonRadarChart(csvData) {
            const rows = csvData.trim().split('\n');
            const headers = rows[0].split(',').slice(1); // Exclude 'Axis'
            const axes = rows.slice(1).map(row => row.split(',')[0]); // First column
            const jsonData = headers.map(() => []);

            for (let i = 1; i < rows.length; i++) {
                const values = rows[i].split(',').slice(1); // Exclude 'Axis'
                for (let j = 0; j < headers.length; j++) {
                    jsonData[j].push({
                        axis: axes[i - 1],
                        value: parseFloat(values[j])
                    });
                }
            }

            return jsonData;
        }


        function csvToJsonNetworkGraph(csvData) {
            const regexNodes = /(?<=Nodes:\s+)[\S\s]+?(?=\s+Links:)/i
            const nodesData = regexNodes.test(csvData) ? csvData.match(regexNodes)[0] : ""

            const regexLinks = /(?<=Links:\s+)[\S\s]+/i
            const linksData = regexLinks.test(csvData) ? csvData.match(regexLinks)[0] : ""

            const nodesRows = nodesData.trim().split('\n');
            const nodes = [];

            for (let i = 1; i < nodesRows.length; i++) {
                const [id, name] = nodesRows[i].split(',');
                nodes.push({ id: id.trim(), name: name.trim() });
            }

            const linksRows = linksData.trim().split('\n');
            const links = [];

            for (let i = 1; i < linksRows.length; i++) {
                const [source, target] = linksRows[i].split(',');
                links.push({ source: source.trim(), target: target.trim() });
            }

            return {
                nodes: nodes,
                links: links
            };
        }


        /*****************************************************************
        credits: The D3.js Graph Gallery - https://d3-graph-gallery.com
        *****************************************************************/

        function drawHeatmap(csvData, title) {
            const data = csvToJson(csvData)

            const margin = { top: 30, right: 30, bottom: 30, left: 30 },
                width = 450 - margin.left - margin.right,
                height = 450 - margin.top - margin.bottom;

            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", width / 2) // Center the title
                .attr("y", -15) // Position from the top
                .text(title);

            // Labels of row and columns
            const myGroups = data.map(e => e.group)
            const myVars = data.map(e => e.name)

            // Build X scales and axis:
            const x = d3.scaleBand()
                .range([0, width])
                .domain(myGroups)
                .padding(0.01);
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x))

            // Build X scales and axis:
            const y = d3.scaleBand()
                .range([height, 0])
                .domain(myVars)
                .padding(0.01);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Build color scale
            const myColor = d3.scaleLinear()
                .range(["white", "#69b3a2"])
                .domain([d3.min(data, d => d.val - 1), d3.max(data, d => d.val + 1)])

            //Read the data

            // create a tooltip
            const tooltip = d3.select("#graph")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px")

            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                tooltip.style("opacity", 1)
            }
            const mousemove = function (event, d) {
                tooltip
                    .html("Val: " + d.val)
                    .style("left", (event.x + 70) + "px")
                    .style("top", event.y + "px")
            }
            const mouseleave = function (d) {
                tooltip.style("opacity", 0)
            }

            // add the squares
            svg.selectAll()
                .data(data, function (d) { return d.group + ':' + d.name; })
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.group) })
                .attr("y", function (d) { return y(d.name) })
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return myColor(d.val) })
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
        }


        function drawScatterPlot(csvData, title) {
            const data = csvToJson(csvData)

            const margin = { top: 30, right: 30, bottom: 30, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", width / 2) // Center the title
                .attr("y", -15) // Position from the top
                .text(title);

            // Add X axis
            const x = d3.scaleLinear()
                .domain([d3.min(data, d => d.x - 1), d3.max(data, d => d.x + 1)])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));
            // Add Y axis
            const y = d3.scaleLinear()
                .domain([d3.min(data, d => d.y), d3.max(data, d => d.y)])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Add the points
            svg
                .append("g")
                .selectAll("dot")
                .data(data)
                .join("circle")
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .attr("r", 5)
                .attr("fill", "#69b3a2")
        }


        function drawBarPlot(csvData, title) {
            const data = csvToJson(csvData)

            const margin = { top: 30, right: 30, bottom: 70, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", width / 2) // Center the title
                .attr("y", -15) // Position from the top
                .text(title);

            // X axis
            const x = d3.scaleBand()
                .range([0, width])
                .domain(data.map(d => d.name))
                .padding(0.2);
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end");

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([d3.min(data, d => d.val), d3.max(data, d => d.val)])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Bars
            svg.selectAll("mybar")
                .data(data)
                .join("rect")
                .attr("x", d => x(d.name))
                .attr("y", d => y(d.val))
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d.val))
                .attr("fill", "#69b3a2")
        }


        function drawPieChart(csvData, title) {
            const fData = csvToJson(csvData)

            const width = 450,
                height = 450,
                margin = 50;

            // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
            const radius = Math.min(width, height) / 2 - margin

            // append the svg object to the div called 'my_dataviz'
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2},${height / 2})`);

            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", svg.attr("width")) // Center the title
                .attr("y", -height / 2 + 20) // Position from the top
                .text(title);

            const data = fData.reduce((accumulator, current) => {
                accumulator[current.name] = current.val;
                return accumulator;
            }, {});

            // set the color scale
            const color = d3.scaleOrdinal()
                .domain(Object.keys(data))
                .range(d3.schemeDark2);

            // Compute the position of each group on the pie:
            const pie = d3.pie()
                .sort(null) // Do not sort group by size
                .value(d => d[1])
            const data_ready = pie(Object.entries(data))

            // The arc generator
            const arc = d3.arc()
                .innerRadius(radius * 0.5)         // This is the size of the donut hole
                .outerRadius(radius * 0.8)

            // Another arc that won't be drawn. Just for labels positioning
            const outerArc = d3.arc()
                .innerRadius(radius * 0.9)
                .outerRadius(radius * 0.9)

            // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
            svg
                .selectAll('allSlices')
                .data(data_ready)
                .join('path')
                .attr('d', arc)
                .attr('fill', d => color(d.data[1]))
                .attr("stroke", "white")
                .style("stroke-width", "2px")
                .style("opacity", 0.7)

            // Add the polylines between chart and labels:
            svg
                .selectAll('allPolylines')
                .data(data_ready)
                .join('polyline')
                .attr("stroke", "black")
                .style("fill", "none")
                .attr("stroke-width", 1)
                .attr('points', function (d) {
                    const posA = arc.centroid(d) // line insertion in the slice
                    const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                    const posC = outerArc.centroid(d); // Label position = almost the same as posB
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
                    return [posA, posB, posC]
                })

            // Add the polylines between chart and labels:
            svg
                .selectAll('allLabels')
                .data(data_ready)
                .join('text')
                .text(d => d.data[0])
                .attr('transform', function (d) {
                    const pos = outerArc.centroid(d);
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                    pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
                    return `translate(${pos})`;
                })
                .style('text-anchor', function (d) {
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                    return (midangle < Math.PI ? 'start' : 'end')
                })
        }


        function drawLineChart(csvData, title) {
            const data = csvToJson(csvData)

            var margin = { top: 30, right: 30, bottom: 30, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", width / 2) // Center the title
                .attr("y", -15) // Position from the top
                .text(title);

            // Add X axis --> it is a date format
            var x = d3.scaleLinear()
                .domain([d3.min(data, d => d.x), d3.max(data, d => d.x)])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([d3.min(data, d => d.y), d3.max(data, d => d.y)])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Add the area
            svg.append("path")
                .datum(data)
                .attr("fill", "#cce5df")
                .attr("stroke", "#69b3a2")
                .attr("stroke-width", 1.5)
                .attr("d", d3.area()
                    .x(function (d) { return x(d.x) })
                    .y0(y(0))
                    .y1(function (d) { return y(d.y) })
                )
        }


        function drawNetwork(csvData, title) {
            const data = csvToJsonNetworkGraph(csvData)

            const margin = { top: 10, right: 30, bottom: 30, left: 40 },
                width = 400 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    `translate(${margin.left}, ${margin.top})`);
            
            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", width/2) // Center the title
                .attr("y", 10) // Position from the top
                .text(title);

            const tooltip = d3.select("#graph")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "black")
                .style("border-radius", "5px")
                .style("padding", "10px")
                .style("color", "white")
            // -2- Create 3 functions to show / update (when mouse move but stay on same circle) / hide the tooltip
            const showTooltip = function (event, d) {
                tooltip
                    .transition()
                    .duration(200)
                tooltip
                    .style("opacity", 1)
                    .html("Name: " + d.name)
                    .style("left", (event.x) / 2 + "px")
                    .style("bottom", (event.y) / 2 + 30 + "px")
            }
            const hideTooltip = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Initialize the links
            const link = svg
                .selectAll("line")
                .data(data.links)
                .join("line")
                .style("stroke", "#aaa")

            // Initialize the nodes
            const node = svg
                .selectAll("circle")
                .data(data.nodes)
                .join("circle")
                .attr("r", 20)
                .style("fill", "#69b3a2")
                .on("mouseover", showTooltip)
                .on("mouseleave", hideTooltip)

            // Let's list the force we wanna apply on the network
            const simulation = d3.forceSimulation(data.nodes)                 // Force algorithm is applied to data.nodes
                .force("link", d3.forceLink()                               // This force provides links between nodes
                    .id(function (d) { return d.id; })                     // This provide  the id of a node
                    .links(data.links)                                    // and this the list of links
                )
                .force("charge", d3.forceManyBody().strength(-400))         // This adds repulsion between nodes. Play with the -400 for the repulsion strength
                .force("center", d3.forceCenter(width / 2, height / 2))     // This force attracts nodes to the center of the svg area
                .on("end", ticked);

            // This function is run at each iteration of the force algorithm, updating the nodes position.
            function ticked() {
                link
                    .attr("x1", function (d) { return d.source.x; })
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) { return d.target.x; })
                    .attr("y2", function (d) { return d.target.y; });

                node
                    .attr("cx", function (d) { return d.x + 6; })
                    .attr("cy", function (d) { return d.y - 6; });
            }
        }


        function drawColoredBubblePlot(csvData, title) {
            const data = csvToJson(csvData)

            const margin = { top: 30, right: 20, bottom: 30, left: 50 },
                width = 500 - margin.left - margin.right,
                height = 420 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add a title to the SVG
            svg.append("text")
                .attr("class", "title")
                .attr("x", width / 2) // Center the title
                .attr("y", -15) // Position from the top
                .text(title);

            // Add X axis
            const x = d3.scaleLinear()
                .domain([d3.min(data, d => d.x), d3.max(data, d => d.x)])
                .range([0, width]);
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x));

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([d3.min(data, d => d.y), d3.max(data, d => d.y)])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Add a scale for bubble size
            const z = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.r)])
                .range([1, 50]);

            // -1- Create a tooltip div that is hidden by default:
            const tooltip = d3.select("#graph")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "black")
                .style("border-radius", "5px")
                .style("padding", "10px")
                .style("color", "white")

            // -2- Create 3 functions to show / update (when mouse move but stay on same circle) / hide the tooltip
            const showTooltip = function (event, d) {
                tooltip
                    .transition()
                    .duration(200)
                tooltip
                    .style("opacity", 1)
                    .html("Name: " + d.name)
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 + 30 + "px")
            }
            const hideTooltip = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Add dots
            svg.append('g')
                .selectAll("dot")
                .data(data)
                .join("circle")
                .attr("class", "bubbles")
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .attr("r", d => z(d.r))
                .style("fill", d => d.c)
                // -3- Trigger the functions
                .on("mouseover", showTooltip)
                .on("mouseleave", hideTooltip)
        }


        /*********************************************************
        credits: Radar Chart by "Nadieh Bremer | Visual Cinnamon (VisualCinnamon.com)" 
        *********************************************************/
        function drawRadarChart(csvData, title) {
            const data = csvToJsonRadarChart(csvData)

            var margin = { top: 70, right: 70, bottom: 70, left: 70 },
                width = Math.min(400, window.innerWidth - 10) - margin.left - margin.right,
                // height = Math.min(width, window.innerHeight - margin.top - margin.bottom - 20);
                height = width

            ////////////////////////////////////////////////////////////// 
            //////////////////// Draw the Chart ////////////////////////// 
            ////////////////////////////////////////////////////////////// 

            var color = d3.scaleOrdinal()
                .range(["#EDC951", "#CC333F", "#00A0B0"]);

            var radarChartOptions = {
                w: width,
                h: height,
                margin: margin,
                maxValue: 0.5,
                levels: 5,
                roundStrokes: true,
                color: color
            };
            //Call function to draw the Radar chart
            RadarChart("#graph", data, radarChartOptions);

            function RadarChart(id, data, options) {
                var cfg = {
                    w: 600,				//Width of the circle
                    h: 600,				//Height of the circle
                    margin: { top: 20, right: 20, bottom: 20, left: 20 }, //The margins of the SVG
                    levels: 3,				//How many levels or inner circles should there be drawn
                    maxValue: 0, 			//What is the value that the biggest circle will represent
                    labelFactor: 1.25, 	//How much farther than the radius of the outer circle should the labels be placed
                    wrapWidth: 60, 		//The number of pixels after which a label needs to be given a new line
                    opacityArea: 0.35, 	//The opacity of the area of the blob
                    dotRadius: 4, 			//The size of the colored circles of each blog
                    opacityCircles: 0.1, 	//The opacity of the circles of each blob
                    strokeWidth: 2, 		//The width of the stroke around each blob
                    roundStrokes: false,	//If true the area and stroke will follow a round path (cardinal-closed)
                    color: d3.scaleOrdinal(d3.schemeCategory10)	//Color function
                };

                //Put all of the options into a variable called cfg
                if ('undefined' !== typeof options) {
                    for (var i in options) {
                        if ('undefined' !== typeof options[i]) { cfg[i] = options[i]; }
                    }//for i
                }//if

                //If the supplied maxValue is smaller than the actual one, replace by the max in the data
                var maxValue = Math.max(cfg.maxValue, d3.max(data, function (i) { return d3.max(i.map(function (o) { return o.value; })) }));

                var allAxis = (data[0].map(function (i, j) { return i.axis })),	//Names of each axis
                    total = allAxis.length,					//The number of different axes
                    radius = Math.min(cfg.w / 2, cfg.h / 2), 	//Radius of the outermost circle
                    Format = d3.format('%'),			 	//Percentage formatting
                    angleSlice = Math.PI * 2 / total;		//The width in radians of each "slice"

                //Scale for the radius
                var rScale = d3.scaleLinear()
                    .range([0, radius])
                    .domain([0, maxValue]);

                /////////////////////////////////////////////////////////
                //////////// Create the container SVG and g /////////////
                /////////////////////////////////////////////////////////

                //Remove whatever chart with the same id/class was present before
                d3.select(id).select("svg").remove();

                //Initiate the radar chart SVG
                var svg = d3.select(id).append("svg")
                    .attr("width", cfg.w + cfg.margin.left + cfg.margin.right)
                    .attr("height", cfg.h + cfg.margin.top + cfg.margin.bottom)
                    .attr("class", "radar" + id);
                //Append a g element		
                var g = svg.append("g")
                    .attr("transform", "translate(" + (cfg.w / 2 + cfg.margin.left) + "," + (cfg.h / 2 + cfg.margin.top) + ")");

                // Add a title to the SVG
                svg.append("text")
                    .attr("class", "title")
                    .attr("x", svg.attr("width") / 2) // Center the title
                    .attr("y", 15) // Position from the top
                    .text(title);

                /////////////////////////////////////////////////////////
                ////////// Glow filter for some extra pizzazz ///////////
                /////////////////////////////////////////////////////////

                //Filter for the outside glow
                var filter = g.append('defs').append('filter').attr('id', 'glow'),
                    feGaussianBlur = filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur'),
                    feMerge = filter.append('feMerge'),
                    feMergeNode_1 = feMerge.append('feMergeNode').attr('in', 'coloredBlur'),
                    feMergeNode_2 = feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

                /////////////////////////////////////////////////////////
                /////////////// Draw the Circular grid //////////////////
                /////////////////////////////////////////////////////////

                //Wrapper for the grid & axes
                var axisGrid = g.append("g").attr("class", "axisWrapper");

                //Draw the background circles
                axisGrid.selectAll(".levels")
                    .data(d3.range(1, (cfg.levels + 1)).reverse())
                    .enter()
                    .append("circle")
                    .attr("class", "gridCircle")
                    .attr("r", function (d, i) { return radius / cfg.levels * d; })
                    .style("fill", "#CDCDCD")
                    .style("stroke", "#CDCDCD")
                    .style("fill-opacity", cfg.opacityCircles)
                    .style("filter", "url(#glow)");

                //Text indicating at what % each level is
                axisGrid.selectAll(".axisLabel")
                    .data(d3.range(1, (cfg.levels + 1)).reverse())
                    .enter().append("text")
                    .attr("class", "axisLabel")
                    .attr("x", 4)
                    .attr("y", function (d) { return -d * radius / cfg.levels; })
                    .attr("dy", "0.4em")
                    .style("font-size", "10px")
                    .attr("fill", "#737373")
                    .text(function (d, i) { return Format(maxValue * d / cfg.levels); });

                /////////////////////////////////////////////////////////
                //////////////////// Draw the axes //////////////////////
                /////////////////////////////////////////////////////////

                //Create the straight lines radiating outward from the center
                var axis = axisGrid.selectAll(".axis")
                    .data(allAxis)
                    .enter()
                    .append("g")
                    .attr("class", "axis");
                //Append the lines
                axis.append("line")
                    .attr("x1", 0)
                    .attr("y1", 0)
                    .attr("x2", function (d, i) { return rScale(maxValue * 1.1) * Math.cos(angleSlice * i - Math.PI / 2); })
                    .attr("y2", function (d, i) { return rScale(maxValue * 1.1) * Math.sin(angleSlice * i - Math.PI / 2); })
                    .attr("class", "line")
                    .style("stroke", "white")
                    .style("stroke-width", "2px");

                //Append the labels at each axis
                axis.append("text")
                    .attr("class", "legend")
                    .style("font-size", "11px")
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.35em")
                    .attr("x", function (d, i) { return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2); })
                    .attr("y", function (d, i) { return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2); })
                    .text(function (d) { return d })
                    .call(wrap, cfg.wrapWidth);

                /////////////////////////////////////////////////////////
                ///////////// Draw the radar chart blobs ////////////////
                /////////////////////////////////////////////////////////

                //The radial line function
                var radarLine = d3.lineRadial()
                    .curve(d3.curveLinearClosed)
                    .radius(function (d) { return rScale(d.value); })
                    .angle(function (d, i) { return i * angleSlice; });

                if (cfg.roundStrokes) {
                    radarLine.curve(d3.curveCardinalClosed)
                }

                //Create a wrapper for the blobs	
                var blobWrapper = g.selectAll(".radarWrapper")
                    .data(data)
                    .enter().append("g")
                    .attr("class", "radarWrapper");

                //Append the backgrounds	
                blobWrapper
                    .append("path")
                    .attr("class", "radarArea")
                    .attr("d", function (d, i) { return radarLine(d); })
                    .style("fill", function (d, i) { return cfg.color(i); })
                    .style("fill-opacity", cfg.opacityArea)
                    .on('mouseover', function (d, i) {
                        //Dim all blobs
                        d3.selectAll(".radarArea")
                            .transition().duration(200)
                            .style("fill-opacity", 0.1);
                        //Bring back the hovered over blob
                        d3.select(this)
                            .transition().duration(200)
                            .style("fill-opacity", 0.7);
                    })
                    .on('mouseout', function () {
                        //Bring back all blobs
                        d3.selectAll(".radarArea")
                            .transition().duration(200)
                            .style("fill-opacity", cfg.opacityArea);
                    });

                //Create the outlines	
                blobWrapper.append("path")
                    .attr("class", "radarStroke")
                    .attr("d", function (d, i) { return radarLine(d); })
                    .style("stroke-width", cfg.strokeWidth + "px")
                    .style("stroke", function (d, i) { return cfg.color(i); })
                    .style("fill", "none")
                    .style("filter", "url(#glow)");

                //Append the circles
                blobWrapper.selectAll(".radarCircle")
                    .data(function (d, i) { return d; })
                    .enter().append("circle")
                    .attr("class", "radarCircle")
                    .attr("r", cfg.dotRadius)
                    .attr("cx", function (d, i) { return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2); })
                    .attr("cy", function (d, i) { return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2); })
                    .style("fill", function (d, i, j) { return cfg.color(j); })
                    .style("fill-opacity", 0.8);

                /////////////////////////////////////////////////////////
                //////// Append invisible circles for tooltip ///////////
                /////////////////////////////////////////////////////////

                //Wrapper for the invisible circles on top
                var blobCircleWrapper = g.selectAll(".radarCircleWrapper")
                    .data(data)
                    .enter().append("g")
                    .attr("class", "radarCircleWrapper");

                //Append a set of invisible circles on top for the mouseover pop-up
                blobCircleWrapper.selectAll(".radarInvisibleCircle")
                    .data(function (d, i) { return d; })
                    .enter().append("circle")
                    .attr("class", "radarInvisibleCircle")
                    .attr("r", cfg.dotRadius * 1.5)
                    .attr("cx", function (d, i) { return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2); })
                    .attr("cy", function (d, i) { return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2); })
                    .style("fill", "none")
                    .style("pointer-events", "all")
                    .on("mouseover", function (d, i) {
                        newX = parseFloat(d3.select(this).attr('cx')) - 10;
                        newY = parseFloat(d3.select(this).attr('cy')) - 10;

                        tooltip
                            .attr('x', newX)
                            .attr('y', newY)
                            .text(Format(i.value))
                            .transition().duration(200)
                            .style('opacity', 1);
                    })
                    .on("mouseout", function () {
                        tooltip.transition().duration(200)
                            .style("opacity", 0);
                    });

                //Set up the small tooltip for when you hover over a circle
                var tooltip = g.append("text")
                    .attr("class", "tooltip")
                    .style("opacity", 0);

                /////////////////////////////////////////////////////////
                /////////////////// Helper Function /////////////////////
                /////////////////////////////////////////////////////////

                //Taken from http://bl.ocks.org/mbostock/7555321
                //Wraps SVG text	
                function wrap(text, width) {
                    text.each(function () {
                        var text = d3.select(this),
                            words = text.text().split(/\s+/).reverse(),
                            word,
                            line = [],
                            lineNumber = 0,
                            lineHeight = 1.4, // ems
                            y = text.attr("y"),
                            x = text.attr("x"),
                            dy = parseFloat(text.attr("dy")),
                            tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

                        while (word = words.pop()) {
                            line.push(word);
                            tspan.text(line.join(" "));
                            if (tspan.node().getComputedTextLength() > width) {
                                line.pop();
                                tspan.text(line.join(" "));
                                line = [word];
                                tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                            }
                        }
                    });
                }//wrap	
            }//RadarChart
        }

    </script>
</body>

</html>
```