{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/kaplay@4000.0.0-alpha.22/dist/kaplay.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            margin: 0;
            width: 100%;
            height: fit-content;
        }

        #main_cont {
            margin: 0 auto;
            width: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: aqua;
        }

        canvas {
            margin: 0 auto;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 3px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont"></div>

    <script>
        const webServerAddress = "http://127.0.0.1:8000"
        const main_cont = document.getElementById("main_cont")
        const CANVAS_WIDTH = 700
        const CANVAS_HEIGHT = 350

        kaplay({
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
        })
        const game = document.querySelector("canvas")


        //ai side
        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                game.style.display = "block"
                error.style.display = "none"
            })
        }


        //ai side
        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipes.length - 1]
            const regexInput = /<result>([\S\s](?!<result>))+?<\/result>/i
            input = regexInput.test(input) ? (input.match(regexInput))[0] : ""
        }


        let toJB = ""
        let gameOver
        let chatData
        let chatDataHist
        let bg
        let toUserProcess = {}
        let toBeRemoved = []
        //ai side
        function loadChatData() {
            chatDataHist = getVariables().chatDataHist == null ? null : JSON.parse(getVariables().chatDataHist)
            chatData = chatDataHist == null ? null : chatDataHist[chatMessages.message_id - 1]
            if (chatData == null) {
                chatData = {}
                chatDataHist = {}
                gameOver = false
                bg = 0
            }
            else {
                gameOver = chatData.gameOver
                newCards = [...chatData.cards]
                bg = chatData.bg
            }
        }


        async function saveData() {
            chatData.gameOver = gameOver
            chatData.userMesEdited = false
            newCards = newCards.map(card => {
                return {
                    name: card.name,
                    img: card.img,
                    rarity: card.rarity,
                    desc: card.desc
                }
            })
            toUserProcess.newCards = newCards
            chatData.bg = bg
            chatData.toUserProcess = toUserProcess
            chatDataHist[chatMessages.message_id] = chatData
            await triggerSlash(`/setvar key=chatDataHist ${JSON.stringify(chatDataHist)}`)
        }


        //ai side
        function verifyInputs(toVerify) {
            if (gameOver) {
                main_cont.parentNode.removeChild(main_cont)
                game.style.display = "none"
                return false
            }

            return true
        }


        function loadImageWithTimeout(imgDesc, rarity, timeout = 5000) {
            let imageUrl
            switch (rarity) {
                case "remover":
                    imageUrl = "https://files.catbox.moe/e8p96j.png"
                    break
                case "combiner":
                    imageUrl = "https://creazilla-store.fra1.digitaloceanspaces.com/icons/3516048/cog-icon-sm.png"
                    break
                case "user":
                    let path = `${webServerAddress}${"{{userAvatarPath}}".replace(/^./, "")}`
                    path = path.replace(" ", "%20")
                    imageUrl = path
                    break
                default: imageUrl = `https://image.pollinations.ai/prompt/digital_illustration_${imgDesc}`
            }

            const placeholderUrl = "https://files.catbox.moe/ekxxn3.png"

            return new Promise((resolve, reject) => {
                const img = new Image();
                let loaded
                fetch(imageUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Network response not ok. URL: ${imageUrl}`);
                        }
                        return response.blob(); // Convert the response to a Blob
                    })
                    .then(imageBlob => {
                        const urlFromFetch = URL.createObjectURL(imageBlob); // Create a local URL for the image
                        img.src = urlFromFetch; // Set the img src to the blob URL
                    })
                    .catch(error => {
                        console.error('There has been a problem with the fetch operation:', error);
                    });

                //timeout
                const timer = setTimeout(() => {
                    resolve(placeholderUrl);
                }, timeout);

                img.onload = () => {
                    loaded = true
                    clearTimeout(timer);
                    resolve(imageUrl);
                };

                img.onerror = () => {
                    loaded = true
                    clearTimeout(timer);
                    resolve(placeholderUrl);
                };
            });
        }


        const CARD_WIDTH = 70
        const CARD_HEIGHT = 100
        async function initCards() {
            const RARITY_COLORS = {
                dangerous: color(212, 34, 34),
                junk: color(160, 140, 108),
                common: color(90, 196, 124),
                rare: color(135, 62, 199),
                legendary: color(247, 142, 22),
                unique: color(235, 207, 87),
                special: color(219, 119, 230),
            }

            const getColor = (rarity) => {
                switch (rarity) {
                    case "bomb":
                    case "dangerous":
                    case "todestroy": return RARITY_COLORS.dangerous
                    case "junk":
                    case "common":
                    case "rare":
                    case "legendary":
                    case "unique": return RARITY_COLORS[rarity]
                    default: return RARITY_COLORS.special
                }
            }

            const getTag = (rarity) => {
                switch (rarity) {
                    case "dangerous":
                    case "junk":
                    case "common":
                    case "rare":
                    case "legendary":
                    case "unique": return "card"
                    default: return rarity
                }
            }

            const promises = newCards.map(card =>
                loadImageWithTimeout(card.img, card.rarity).then(imgLink => {
                    card.imgLink = imgLink;
                })
            );

            await Promise.all(promises)

            newCards.forEach((card, i) => {
                const c = add([
                    rect(CARD_WIDTH, CARD_HEIGHT),
                    area(),
                    scale(1.25),
                    outline(1),
                    getColor(card.rarity),
                    pos(
                        //x
                        card.rarity === "combiner" || card.rarity === "remover" ?
                            rand(canvas.width - canvas.width * 0.25 + CARD_WIDTH * 0.5, canvas.width - CARD_WIDTH * 0.5) :
                            rand(CARD_WIDTH * 0.5, canvas.width * 0.5 - CARD_WIDTH * 0.5),
                        //y
                        rand(CARD_HEIGHT * 0.5, canvas.height - CARD_HEIGHT * 0.5)),
                    anchor("center"),
                    getTag(card.rarity),
                    "card",
                    z(0),
                    {
                        update() {
                            this.z = this.pos.y
                        }
                    },
                    {
                        name: card.name,
                        img: card.img,
                        rarity: card.rarity,
                        desc: card.desc,
                        attached: []
                    },
                ])

                //add pic
                loadSprite(card.img, card.imgLink)
                c.add([
                    sprite(card.img, {
                        width: 64,
                        height: card.rarity === "user" ? 96 : 64
                    }),
                    // rect(64, 64),
                    color(255, 255, 255),
                    pos(-32, card.rarity === "user" ? -48 : -40),
                    z(0),
                    {
                        update() {
                            this.z = c.pos.y;
                        }
                    },
                ])
            });

            //card dragging
            let startDragPos = vec2(0)
            let newDragPos = vec2(0)
            let held = []
            onClick("card", function (card) {
                if (held.length > 0) {
                    return
                }
                let toDrag = hovered[0]
                startDragPos = mousePos()
                held.push(card.id)
                const drag = onMouseMove(function () {
                    newDragPos = mousePos().sub(startDragPos)
                    startDragPos = mousePos()
                    toDrag.pos = toDrag.pos.add(newDragPos)
                })
                onMouseRelease("left", () => {
                    if (drag != undefined) {
                        drag.cancel()
                    }
                    held = []
                })
            })

            const TOOLTIP_WIDTH = 300
            const TOOLTIP_HEIGHT = 150
            //card hover
            const tooltip = add([
                rect(TOOLTIP_WIDTH, TOOLTIP_HEIGHT),
                pos(canvas.height),
                color(107, 115, 108),
                opacity(0.9),
                z(canvas.height),
                {
                    update() {
                        if (this.hidden) {
                            this.pos = vec2(canvas.height)
                        }
                        else {
                            this.pos = mousePos()
                        }
                    }
                },
                "tooltip"
            ])

            const tooltipTxt = tooltip.add([
                z(canvas.height + 1),
                pos(5),
                color(255, 255, 255),
                text("", {
                    size: 16,
                    width: TOOLTIP_WIDTH - 10
                }),
                "tooltipText"
            ])

            tooltip.hidden = true
            let hovered = []
            onHover("card", function (card) {
                hovered.push(card)
                hovered = hovered.sort((a, b) => b.z - a.z)
                tooltipTxt.text = `${hovered[0].name}
${hovered[0].desc}`
                tooltip.hidden = false
                tooltip.pos = mousePos()
            })

            onHoverEnd("card", function (card) {
                hovered = hovered.filter(c => c.id !== card.id)
                if (hovered.length > 0) {
                    tooltipTxt.text = `${hovered[0].name}
${hovered[0].desc}`
                    return
                }
                tooltip.hidden = true
                hovered = []
            })
        }


        async function updateUtilsAttached() {
            //remover
            const removers = get("remover")
            removers.forEach(remover => {
                remover.attached.forEach(element => {
                    toBeRemoved.push({
                        name: element.name,
                        img: element.img,
                        rarity: element.rarity,
                        desc: element.desc
                    })
                })
            });

            //combiners
            let combinedCnt = 0
            const combiners = get("combiner")
            toJB = ""
            combiners.forEach((combiner, i) => {
                toJB += `- Combination ${i + 1}:
`
                combiner.attached.forEach(element => {
                    combinedCnt++
                    let desc = element.desc
                    if (element.rarity === "user") {
                        desc = ""
                    }
                    toJB += `- ${element.name}${desc === "" ? "" : " - " + desc}
`
                });
            });
            if (combinedCnt === 0) {
                toJB = "none"
            }

            toUserProcess.toBeRemoved = toBeRemoved
            prepToUserProcess()
            await updateJB()
            await saveData()
        }


        function isSpecial(card) {
            switch (card.rarity) {
                case "user":
                case "todestroy":
                case "bomb":
                case "dangerous":
                case "unique":
                    return true
            }
            return false
        }


        function cardCollide(card, utilCard, util) {
            const combinerId = utilCard.id
            if (card.is("combiner") && utilCard.is(util)) {
                return
            }
            if (card.is("remover") && utilCard.is(util)) {
                return
            }
            const entry = actQueue.filter(e => e.action === "attach" && e.card.id == card.id)
            if (entry.length > 0) {
                actQueue = actQueue.filter(e => e.action === "attach" && e.card.id != card.id)
            }
            actQueue.push({
                utilCard: utilCard,
                card: card,
                action: "attach"
            })
        }


        function cardCollideEnd(card, utilCard, util) {
            const combinerId = utilCard.id
            if (card.is("combiner") && utilCard.is(util)) {
                return
            }
            if (card.is("remover") && utilCard.is(util)) {
                return
            }
            const entry = actQueue.filter(e => e.action === "detach" && e.utilCard.id == utilCard.id && e.card.id == card.id)
            if (entry.length > 0) {
                actQueue = actQueue.filter(e => e.action === "detach" && e.utilCard.id != utilCard.id && e.card.id != card.id)
            }
            const aEntry = actQueue.filter(e => e.action === "attach" && e.utilCard.id == utilCard.id && e.card.id == card.id)
            if (aEntry.length > 0) {
                actQueue = actQueue.filter(e => e.action === "attach" && e.utilCard.id != utilCard.id && e.card.id != card.id)
                return
            }
            actQueue.push({
                utilCard: utilCard,
                card: card,
                action: "detach"
            })
        }


        function cardDragged(utilCard) {
            if (combinersPos[utilCard.id] == utilCard.pos) {
                return
            }
            combinersPos[utilCard.id] = utilCard.pos
            refreshAttached(utilCard)
        }


        let actQueue = []
        let combinersPos = {}
        const MAX_ATTACH_LIMIT = 5
        function initCombinersAndRemovers() {
            onMouseRelease("left", function () {
                while (actQueue.length > 0) {
                    const entry = actQueue.shift()
                    if (entry.action === "attach") {
                        if (entry.utilCard.is("combiner") && entry.utilCard.attached.length >= MAX_ATTACH_LIMIT) {
                            debug.log(`Can't combine more than ${MAX_ATTACH_LIMIT} cards.`)
                            continue
                        }
                        if (entry.utilCard.is("remover") && isSpecial(entry.card)) {
                            debug.log(`Can't remove ${entry.card.name}.`)
                            continue
                        }
                        detachAll(entry.card)
                        entry.utilCard.attached.push(entry.card)
                    }
                    else {
                        entry.utilCard.attached = entry.utilCard.attached.filter(card => card.id != entry.card.id)
                    }
                    refreshAttached(entry.utilCard)
                }
                updateUtilsAttached()
            })

            onCollide("card", "combiner", function (card, combiner) {
                cardCollide(card, combiner, "combiner")
            })

            onCollideEnd("card", "combiner", function (card, combiner) {
                cardCollideEnd(card, combiner, "combiner")
            })

            onCollide("card", "remover", function (card, remover) {
                cardCollide(card, remover, "remover")
            })

            onCollideEnd("card", "remover", function (card, remover) {
                cardCollideEnd(card, remover, "remover")
            })

            onUpdate("combiner", function (combiner) {
                cardDragged(combiner)
            })

            onUpdate("remover", function (remover) {
                cardDragged(remover)
            })
        }


        function refreshAttached(utilCard) {
            let i = 0
            for (const card of utilCard.attached) {
                i++
                const mult = (i*3) + 15
                card.pos = vec2(utilCard.pos.x + (mult), utilCard.pos.y + (mult))
            }
        }


        function detachAll(card) {
            const utilCardsArr = [...get("combiner"), ...get("remover")]
            utilCardsArr.forEach(utilCard => {
                utilCard.attached = utilCard.attached.filter(c => card.id != c.id)
            });
        }


        function setBG(url) {
            loadSprite("bg", url)
            add([
                sprite("bg", {
                    width: CANVAS_WIDTH,
                    height: CANVAS_HEIGHT,
                }),
                z(-1)
            ])
        }


        let newCards = []
        async function parseCommands(commands) {
            const regexAdd = /add/i
            const regexAddName = /(?<=add\(("[\S\s]+?",\s*){0}")[\S\s]+?(?=",|"\))/i
            const regexAddImg = /(?<=add\(("[\S\s]+?",\s*){1}")[\S\s]+?(?=",|"\))/i
            const regexAddRarity = /(?<=add\(("[\S\s]+?",\s*){2}")[\S\s]+?(?=",|"\))/i
            const regexAddDesc = /(?<=add\(("[\S\s]+?",\s*){3}")[\S\s]+?(?=",|"\))/i
            const regexAddCount = /(?<=add\(("[\S\s]+?",\s*){4})[\d]+?(?=\))/i
            const regexRemoveName = /(?<=remove\(")[\S\s]+?(?="\))/i
            for (const com of commands) {
                const commandStr = com[0]
                if (regexAdd.test(commandStr)) {
                    //add
                    const name = regexAddName.test(commandStr) ? commandStr.match(regexAddName)[0] : ""
                    const img = regexAddImg.test(commandStr) ? commandStr.match(regexAddImg)[0] : ""
                    const rarity = regexAddRarity.test(commandStr) ? commandStr.match(regexAddRarity)[0] : ""
                    const desc = regexAddDesc.test(commandStr) ? commandStr.match(regexAddDesc)[0] : ""
                    let count = regexAddCount.test(commandStr) ? Number.parseInt(commandStr.match(regexAddCount)[0]) : 1
                    if (verifyCommandInputs([name, img, rarity, count]) === false) {
                        continue
                    }
                    count = Math.min(count, 10)
                    for (let i = 0; i < count; i++) {
                        if (rarity === "unique" && newCards.filter(card => card.name === name).length > 0) {
                            //remove existing unique with same name
                            newCards = newCards.filter(card => card.name !== name)
                        }
                        newCards.push({
                            name: name,
                            img: img,
                            rarity: rarity,
                            desc: desc
                        })
                    }
                }
                else {
                    //remove
                    const name = regexRemoveName.test(commandStr) ? commandStr.match(regexRemoveName)[0] : ""
                    if (name !== "") {
                        const index = newCards.findIndex(obj => obj.name === name);
                        if (index !== -1) {
                            newCards.splice(index, 1);
                        }
                    }
                }
            }
        }


        function verifyCommandInputs(inputs) {
            for (const inp of inputs) {
                if (inp === "") return false
            }
            return true
        }


        let crew = ["todestroy", "todestroy", "dangerous", "dangerous", "dangerous", "dangerous", "dangerous"]
        function shuffleImposters() {
            for (let i = crew.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1)); // Random index
                [crew[i], crew[j]] = [crew[j], crew[i]]; // Swap elements
            }

            let intro4Arr = introCards[4]
            let i = 0
            intro4Arr.forEach(element => {
                if (element.rarity === "") {
                    element.rarity = crew[i]
                    i++
                }
            });
        }


        const introCards = [
            [
                //0 alchemy
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Renna", img: "young_female_elf_fantasy_setting", rarity: "unique", desc: "An elf who is training to become an alchemist." },
                { name: "Yellow Potion", img: "sparkling_yellow_potion", rarity: "rare", desc: "" },
                { name: "Catalyst", img: "crystallized_bottle_with_orange_liquid", rarity: "rare", desc: "" },
                { name: "Red Potion", img: "sparkling_red_potion", rarity: "rare", desc: "" },
                { name: "Mushrooms", img: "mushrooms", rarity: "common", desc: "" },
                { name: "Herbs", img: "herbs", rarity: "common", desc: "" },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
            [
                //1 stranded on an island
                { name: "Megan", img: "female_messy_hair_upset", rarity: "unique", desc: "Shipwreck survivor. Megan has been in a terrible mood ever since the shipwreck." },
                { name: "Anna", img: "little_girl_smile", rarity: "unique", desc: "Shipwreck survivor. Despite being a kid, Anna seems optimistic." },
                { name: "Palm Tree", img: "palm_tree_tall", rarity: "common", desc: "" },
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Medkit", img: "medkit_containing_medicinal_supplies", rarity: "rare", desc: "" },
                { name: "Shovel", img: "shovel", rarity: "rare", desc: "" },
                { name: "Ration", img: "wrapped_food_ration", rarity: "rare", desc: "" },
                { name: "Ration", img: "wrapped_food_ration", rarity: "rare", desc: "" },
                { name: "Stone", img: "stone", rarity: "junk", desc: "" },
                { name: "Stone", img: "stone", rarity: "junk", desc: "" },
                { name: "Hermit Crab", img: "hermit_crab", rarity: "rare", desc: "" },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
            [
                //2 prison
                { name: "Prison Wall", img: "prison_cell_bars", rarity: "todestroy", desc: "{{user}} cannot escape until the prison wall is destroyed." },
                { name: "Bar of Soap", img: "bar_of_soap", rarity: "common", desc: "" },
                { name: "Warden Gonzales", img: "male_police_officer_with_mustache_frowning", rarity: "unique", desc: "A bully and a snob. He uses excessive force against prisoners." },
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Warden Lani", img: "female_police_officer_menacing_smile", rarity: "unique", desc: "An ordinary policewoman. There's nothing special about her." },
                { name: "Shiv", img: "a_very_sharp_metallic_shiv", rarity: "rare", desc: "" },
                { name: "Prisoner Fineg", img: "man_in_prisoner_outfit_wearing_glasses_grinning", rarity: "unique", desc: "Incarcerated on charges of child abuse." },
                { name: "Prisoner Tyrone", img: "bald_man_in_prisoner_outfit_muscles_african_american", rarity: "unique", desc: "Jailed for sexual assault." },
                { name: "Prisoner Jamila", img: "woman_in_prisoner_outfit_slim_tattoo_frowning", rarity: "unique", desc: "A scam artist who was caught in a sting operation." },
                { name: "Prisoner Old Jones", img: "old_man_in_prisoner_outfit_long_beard_bald", rarity: "unique", desc: "Indicted for multiple counts of first-degree murder." },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
            [
                //3 defuse the bomb
                { name: "Time Bomb", img: "time_bomb_with_various_electronics_wires_and_digital_timer", rarity: "bomb", desc: "Defuse the bomb or everyone dies." },
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Flor", img: "female_in_office_uniform", rarity: "unique", desc: "A regular office lady who works in the HR department." },
                { name: "Coffee", img: "hot_coffee_in_a_styro_cup", rarity: "common", desc: "" },
                { name: "Purse", img: "purse", rarity: "common", desc: "" },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
            [
                //4 imposters in space station
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Crewmate Red", img: "astronaut_in_red_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Crewmate Orange", img: "astronaut_in_orange_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Crewmate Yellow", img: "astronaut_in_yellow_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Crewmate Green", img: "astronaut_in_green_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Crewmate Blue", img: "astronaut_in_blue_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Crewmate Pink", img: "astronaut_in_pink_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Crewmate Purple", img: "astronaut_in_purple_spacesuit", rarity: "", desc: "Fellow crew member" },
                { name: "Corpse of Crewmate Grey", img: "astronaut_in_grey_spacesuit_lying_on_the_floor_dead", rarity: "unique", desc: "He's dead. An imposter killed him." },
                { name: "Fire Axe", img: "fire_axe", rarity: "common", desc: "" },
                { name: "Pistol", img: "pistol", rarity: "rare", desc: "" },
                { name: "Crowbar", img: "crowbar", rarity: "common", desc: "" },
                { name: "Wrench", img: "wrench", rarity: "common", desc: "" },
                { name: "Faulty Machinery", img: "faulty_machinery_broken_electronics_sparking_3", rarity: "unique", desc: "It needs to be fixed." },
                { name: "Faulty Machinery", img: "faulty_machinery_broken_electronics_sparking_4", rarity: "unique", desc: "It needs to be fixed." },
                { name: "Faulty Machinery", img: "faulty_machinery_broken_electronics_sparking_5", rarity: "unique", desc: "It needs to be fixed." },
                { name: "Faulty Machinery", img: "faulty_machinery_broken_electronics_sparking_5", rarity: "unique", desc: "It needs to be fixed." },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
            [
                //5 ritual
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Mandy", img: "goth_girl_creepy_smile", rarity: "unique", desc: "A crazy girl who's into occult stuff." },
                { name: "Necronomicon", img: "the_book_necronomicon_creepy_face_on_the_cover", rarity: "legendary", desc: "" },
                { name: "Ritual Circle", img: "ritual_circle_drawn_on_the_floor", rarity: "rare", desc: "" },
                { name: "Heart", img: "biology_internal_organ_human_heart", rarity: "rare", desc: "" },
                { name: "Candle", img: "lit_up_candle", rarity: "common", desc: "" },
                { name: "Candle", img: "lit_up_candle", rarity: "common", desc: "" },
                { name: "Candle", img: "lit_up_candle", rarity: "common", desc: "" },
                { name: "Knife", img: "a_sharp_knife", rarity: "common", desc: "" },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
            [
                //6 trading
                { name: "{{user}}", img: "{{user}}", rarity: "user", desc: "You. Keep this card alive." },
                { name: "Paperclip", img: "a_single_metal_paperclip", rarity: "common", desc: "" },
                { name: "Combiner", img: "combiner", rarity: "combiner", desc: "Place the cards you want to combine here." },
            ],
        ]

        const introBG = [
            "https://files.catbox.moe/bymqxt.jpg",

            "https://images.ctfassets.net/ql4dheqoo9gp/3VCbirMs7dx006dE2HEo2Q/b0be53f4e8111cc166659eb0d77804c2/standard.png",

            "https://as1.ftcdn.net/v2/jpg/01/03/82/80/1000_F_103828083_8l1byXyqha0AaEkQXYYwKhzyxqHjMfcK.jpg",

            "https://www.databankimx.com/wp-content/uploads/2022/07/iStock-1313115119.jpg",

            "https://files.catbox.moe/urgops.jpg",

            "https://as1.ftcdn.net/v2/jpg/03/46/36/52/1000_F_346365251_6Ei4WAsrLXutw39QpAcibcsDhtX8kZph.jpg",

            "https://files.catbox.moe/hjgz3d.jpg"
        ]


        //user, bomb, todestroy
        function checkIfUserAlive() {
            let userAlive = false
            let toDestroyCount = 0
            newCards.forEach(card => {
                switch (card.rarity) {
                    case "user":
                        userAlive = true
                        break
                }
            });

            if (userAlive === false) {
                toJB = `- {{user}} is dead. Game over.
`
                toastr.error("Your card was removed. Game over.")
                return false
            }

            return true
        }


        //card - { name: "Dog", img: "dog", rarity: "common", desc: "description" },
        //main
        document.addEventListener("DOMContentLoaded", async function () {
            //ai
            initError()
            await loadAIReply()

            //ai user
            loadChatData()

            //ai
            //intro handler - for multi intro cards
            if (chatMessages.message_id === 0) {
                if (chatMessages.swipe_id === 4) {
                    shuffleImposters()
                }
                newCards = [...introCards[chatMessages.swipe_id]]
                bg = chatMessages.swipe_id
            }

            //ai
            //regexes here
            const regexCommands = /(remove|add)\([^\n]+?\)/ig
            const regexCommandsTest = /(remove|add)\([^\n]+?\)/ig
            const commands = regexCommandsTest.test(input) ? input.matchAll(regexCommands) : ""
            if (verifyInputs(commands) === false) {
                await saveData()
                return
            }

            //main func start here
            await parseCommands(commands)

            if (checkIfUserAlive() === false) {
                gameOver = true
                await updateJB()
                await saveData()
                return
            }

            setBG(introBG[bg])
            await initCards()
            initCombinersAndRemovers()

            prepToUserProcess()
            await updateJB()
            await saveData()
            document.querySelector("body").style.height = "fit-content"
        })


        //ai side
        function prepToUserProcess() {
            //process stuff to be updated on user side
            if (triggerSpecialCards() === false) {
                gameOver = true
                return
            }
            
            if (gameOver) {
                return
            }

            if (/none/i.test(toJB) === false) {
                toJB = `Please include the following at the beginning of the next response:
<result>
[Function calls here.]
</result>

Inside the result tags are function calls that simulate the reactions based on the combinations of entities.
Functions available are:
- add(name, imageDescription, rarity, flavorText, count)
- remove(name)
Parameters:
- name - a string. As much as possible, pass a noun only. Use imageDescription and flavorText params for descriptors/adjectives.
- imageDescription - a string that vividly_describes_this_entity_separated_by_underscores.
- rarity - a string that describes how rare this entity is. Rarities include: "junk", "common", "rare", "legendary", "dangerous" and "unique". Unique entities are one-of-a-kind and most likely have their own name.
- flavorText - if the entity has something of note, then include a short single sentence flavor text. Otherwise leave an empty string ("").
- count - defaults to 1, if multiple entity are created, specify an integer.

Like programming, the sequence must be methodical and thorough. No shortcuts.
To use the functions: First, take a look at the combinations. Which entity will be added? Which one will be removed? Here's an example:
Combination 1:
- Baseball Bat
- Zombie
- {{user}}

Depending on the context, {{user}} may be using the baseball bat to strike the zombie. However, the baseball bat's condition may be low and is destroyed in the process. The function sequence may be:
remove("Zombie") //remove the "Zombie". As much as possible, match the existing names.
remove("Baseball Bat") //remove the baseball bat since it was destroyed when hitting the zombie
add("Zombie Corpse", "bloody_zombie_corpse_lying_on_the_floor", "common", "") //add a zombie corpse entity

Keep it simple. Do whatever seems most interesting and funny and makes the most sense for the situation.
Briefing done. Here's the actual data. Keep it simple. First thoughts are the best thoughts:
` + toJB

                if ("{{random: true, false, false, false}}" === "true") {
                    toJB += `
To spice things up, add three random entities with the following rarities: {{random::"junk"::"junk"::"junk"::"common"::"common"::"common"::"common"::"common"::"rare"::"unique"::"legendary"::"dangerous"}}, {{random::"junk"::"junk"::"junk"::"common"::"common"::"common"::"common"::"common"::"rare"::"unique"::"legendary"::"dangerous"}}, and {{random::"junk"::"junk"::"junk"::"common"::"common"::"common"::"common"::"common"::"rare"::"unique"::"legendary"::"dangerous"}}
                    `
                }
            }
            else {
                toJB = ""
            }
        }


        function triggerSpecialCards() {
            toUserProcess.bombCooldown = chatData.bombCooldown
            toUserProcess.bombInfo = chatData.bombInfo
            toUserProcess.hasDestroyGoal = chatData.hasDestroyGoal
            //user, bomb, todestroy
            let userAlive = false
            let toDestroyCount = 0
            newCards.forEach(card => {
                switch (card.rarity) {
                    case "user":
                        userAlive = true
                        break
                    case "bomb":
                        if (toUserProcess.bombCooldown === undefined) {
                            toUserProcess.bombCooldown = 5
                            toUserProcess.bombInfo = `They haven't done anything to the bomb yet. The only way to defuse the bomb is by {{random::cutting the red wire::cutting the yellow wire::cutting the blue wire::spilling liquid on it}}. Otherwise nothing happens. Let {{user}} figure it out.
`
                        }
                        else {
                            toUserProcess.bombCooldown--
                        }
                        toJB += `${toUserProcess.bombInfo}
`
                        break
                    case "todestroy":
                        if (toUserProcess.hasDestroyGoal === undefined) {
                            toUserProcess.hasDestroyGoal = true
                        }
                        toDestroyCount++
                        break
                }
            });

            if (toUserProcess.bombCooldown === 0) {
                toJB = `- The bomb exploded. Everyone died. Game over.
`
                toastr.error("The bomb exploded. Game over.")
                return false
            }
            if (toDestroyCount === 0 && toUserProcess.hasDestroyGoal != undefined) {
                toJB = `- Goal achieved. {{user}} destroyed every obstacle in his way. Game over.
`
                toastr.success("Goal achieved. Game over.")
                return false
            }
            if (userAlive === false) {
                toJB = `- {{user}} is dead. Game over.
`
                toastr.error("Your card was removed. Game over.")
                return false
            }

            return true
        }


        //ai side
        async function updateJB() {
            await insertOrAssignVariables({ jbout: toJB })
            toJB = ""
        }
    </script>
</body>

</html>
```