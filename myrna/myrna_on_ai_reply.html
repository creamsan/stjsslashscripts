{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/kaplay@4000.0.0-alpha.22/dist/kaplay.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            margin: 0;
            width: 100%;
            height: fit-content;
        }

        #main_cont {
            margin: 0 auto;
            width: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            margin-bottom: 5px;
        }

        canvas {
            margin: 0 auto;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 3px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }

        #doneBtn {
            background-color: darkcyan;
            padding: 5px;
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont">
        <button class="stylized-button" id="doneBtn">Done</button>
    </div>

    <script>
        const EXTRA_WORDS = [
            "bitch",
            "bitches",
            "fuck",
            "fucks",
            "nigga",
            "niggas",
            "cock",
            "cocks",
            "fag",
            "fags",
            "retard",
            "retards"
        ]

        const main_cont = document.getElementById("main_cont")
        const doneBtn = document.getElementById("doneBtn")
        const CANVAS_WIDTH = 650
        const CANVAS_HEIGHT = 400

        kaplay({
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
        })
        const game = document.querySelector("canvas")


        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                error.style.display = "none"
            })
        }


        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipe_id]

            //filter out cot
            const regexCot = /[\S\s]+<\/think(ing)?>\s+/i
            input = input.replace(regexCot, "")
        }


        let toJB = ""
        let swiped
        let aiMesChanged
        let userMesEdited
        let chatData
        let chatDataHist
        let toUserProcess = {}
        function loadChatData() {
            chatDataHist = getVariables().chatDataHist == null ? null : JSON.parse(getVariables().chatDataHist)
            chatData = chatDataHist == null ? null : chatDataHist[chatMessages.message_id - 1]
            if (chatData == null) {
                chatData = {}
                chatDataHist = {}
                swiped = false
                aiMesChanged = false
            }
            else {
                swiped = chatData.swiped
                aiMesChanged = chatData.aiMesChanged
            }
        }


        async function saveData() {
            chatData.swiped = swiped
            chatData.aiMesChanged = aiMesChanged
            chatData.userMesEdited = false
            chatData.toUserProcess = toUserProcess
            chatDataHist[chatMessages.message_id] = chatData
            await triggerSlash(`/setvar key=chatDataHist ${JSON.stringify(chatDataHist)}`)
        }


        function verifyInputs() {
            if (input == "") {
                main_cont.style.display = "none"
                error.style.display = "flex"
                return false
            }

            if (aiMesChanged) {
                main_cont.style.display = "none"
                game.style.display = "none"
                return false
            }

            return true
        }


        async function handleSwipe() {
            eventOnce(tavern_events.MESSAGE_SWIPED, async function () {
                //change some data and save everything before swipe
                swiped = true
                aiMesChanged = false
                await saveData()
            })
            if (swiped) {
                const newGenSwipes = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0].swipes
                const swipeGen = newGenSwipes[newGenSwipes.length - 1]
                if (swipeGen === "...") {
                    await saveData()
                    return true
                }
                input = swipeGen
                swiped = false
            }
            return false
        }


        function modifyAIMes(msg, origMsg) {
            // note: hacky - fix later 
            // send the modified AI message
            // send the orig AI message as hidden
            // hide the modified AI message
            // cut the unmodified ai message
            if (aiMesChanged === false) {
                aiMesChanged = true
                triggerSlash(`/sendas name="{{char}}" <details><summary>Original</summary>
${origMsg}
</details> |
                    /sendas name="{{char}}" ${msg} |
                    /cut {{lastMessageId}} |
                    /hide {{lastMessageId}}
                `)
            }
        }


        function getMatches(regex, str) {
            const matches = [];
            const matchR = str.matchAll(regex)
            for (const match of matchR) {
                matches.push({
                    match: match[0],
                    index: match.index,
                    original: match[0]
                });
            }
            return matches;
        }


        function getWords(regex, str) {
            const matches = [];
            const matchR = str.matchAll(regex)
            for (const match of matchR) {
                matches.push(match[0]);
            }
            return matches;
        }


        function hasPunctuation(str) {
            const punctuationRegex = /[!.,;:'"()?*]/i
            return punctuationRegex.test(str)
        }


        const TEXT_SIZE = 16
        let assoc = []
        function initUI(dialogues, words) {
            //bg
            loadSprite("bg", "https://files.catbox.moe/zud2hn.jpg")
            add([
                sprite("bg"),
                z(-1),
                pos(0, -150)
            ])


            let str = ""
            let toConstruct = []
            dialogues.forEach((d, di) => {
                //togetpos string
                str += d.match + "\n"

                //choose words to be blank - 1 per line
                const dialogueWords = getMatches(/[^\s]+/gi, d.match)
                let toChooseIdx = dialogueWords.map((e, i) => i)
                if (dialogueWords.length >= 5) {
                    for (let i = 0; i < 1; i++) {
                        let idxRand = -1
                        let dWord = ""
                        while (dWord === "" || dWord.original.length <= 2 || hasPunctuation(dWord.original)) {
                            if (toChooseIdx.length === 0) {
                                return
                            }
                            idxRand = toChooseIdx[Math.floor(Math.random() * toChooseIdx.length)]
                            toChooseIdx = toChooseIdx.filter(i => i !== idxRand)
                            dWord = dialogueWords[idxRand]
                        }
                        words.push(dialogueWords[idxRand].original)
                        dialogueWords[idxRand].match = "???"

                        assoc.push({
                            dialogueIdx: di,
                            idx: dialogueWords[idxRand].index,
                            orig: dWord.original
                        })
                    }
                }

                //toConstruct
                dialogueWords.forEach(d => {
                    if (d.match !== "???") toConstruct.push(d.match + " ")
                    else toConstruct.push(d.match)
                });

            });

            //sort by index
            assoc = assoc.sort((a, b) => a.idx - b.idx)
                .sort((a, b) => a.dialogueIdx - b.dialogueIdx)


            //associate blanks
            for (let i = 0, j = 0; i < toConstruct.length; i++) {
                if (toConstruct[i] === "???") {
                    assoc[j].toConstructIdx = i
                    j++
                }
            }


            //approximate height of textbox
            const toGetPos = add([
                anchor("center"),
                pos(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2),
                color(185, 240, 186),
                text(str, {
                    size: TEXT_SIZE,
                    width: CANVAS_WIDTH - 20,
                    font: "monospace"
                }),
                opacity(0)
            ])
            const startV = vec2(10, (CANVAS_HEIGHT / 2) - (toGetPos.height / 2) - 20)
            destroy(toGetPos)


            //scatter words
            let blankLongest = 0
            let blankHeight = 0
            words.forEach(w => {
                const word = add([
                    anchor("center"),
                    pos(randomXY()),
                    text(w, {
                        size: TEXT_SIZE,
                        font: "monospace"
                    }),
                    area(),
                    "word"
                ])
                if (word.width > blankLongest) {
                    blankLongest = word.width
                    blankHeight = word.height
                }
            });


            //word dragging
            let startDragPos = vec2(0)
            let newDragPos = vec2(0)
            let held = []
            onClick("word", function (word) {
                if (held.length > 0) {
                    return
                }
                let toDrag = word
                startDragPos = mousePos()
                held.push(word.id)
                const drag = onMouseMove(function () {
                    newDragPos = mousePos().sub(startDragPos)
                    startDragPos = mousePos()
                    toDrag.pos = toDrag.pos.add(newDragPos)
                })
                onMouseRelease("left", () => {
                    if (drag != undefined) {
                        drag.cancel()
                    }
                    held = []
                })
            })


            //dialogues
            let currentV = startV.clone()
            toConstruct.forEach((elem, i) => {
                if (elem === "???") {
                    const e = add([
                        anchor("center"),
                        pos(currentV.x + blankLongest * .5, currentV.y + blankHeight * .5),
                        color(185, 240, 186),
                        text(elem, {
                            size: TEXT_SIZE,
                            width: blankLongest + 5,
                            font: "monospace",
                            align: "center"
                        }),
                        color(240, 86, 86),
                        area(),
                        "blank",
                        { lastInteract: null }
                    ])
                    currentV.x += e.width + 8
                    if (currentV.x > CANVAS_WIDTH) {
                        currentV.x = startV.x
                        currentV.y = currentV.y + TEXT_SIZE + 8
                        e.pos = vec2(currentV.x + blankLongest * .5, currentV.y + blankHeight * .5)
                        currentV.x += e.width
                    }

                    assoc.filter(a => a.toConstructIdx === i)[0].blankId = e.id
                }
                else {
                    const e = add([
                        pos(currentV),
                        color(185, 240, 186),
                        text(elem, {
                            size: TEXT_SIZE,
                            font: "monospace",
                        })
                    ])
                    currentV.x += e.width
                    if (currentV.x > CANVAS_WIDTH) {
                        currentV.x = startV.x
                        currentV.y = currentV.y + TEXT_SIZE + 8
                        e.pos = vec2(currentV.x, currentV.y)
                        currentV.x += e.width
                    }
                }
            });


            //filling the blanks
            onMouseRelease("left", function () {
                const blanks = get("blank")
                blanks.forEach(b => {
                    b.opacity = 1
                    if (b.lastInteract != null) {
                        b.opacity = 0
                        b.lastInteract.pos = vec2(b.pos)
                    }
                });
            })

            onCollide("blank", "word", function (blank, word) {
                if (blank.lastInteract != null && blank.lastInteract.id != word.id) {
                    return
                }
                detachAll(word)
                blank.lastInteract = word
            })

            onCollideEnd("blank", "word", function (blank, word) {
                if (blank.lastInteract != null && blank.lastInteract.id == word.id) {
                    word.lastInteract = null
                    blank.lastInteract = null
                }
            })

        }


        function detachAll(word) {
            const blanks = get("blank")
            blanks.forEach(b => {
                if (b.lastInteract != null && b.lastInteract.id == word.id) {
                    b.lastInteract = null
                }
            });
        }


        function randomXY() {
            const x = randi(15, CANVAS_WIDTH - 15)
            let y
            if (x > 50 && x < CANVAS_WIDTH - 50) {
                let up = randi(0, 101) < 50
                y = up ? randi(15, 50) : randi(CANVAS_HEIGHT - 50, CANVAS_HEIGHT - 15)
            }
            else {
                y = randi(15, CANVAS_HEIGHT - 15)
            }

            return vec2(x, y)
        }


        function replaceAtIndex(str, regex, replacement, startIndex) {
            const globalRegex = new RegExp(regex, 'g');
            let match;
            while ((match = globalRegex.exec(str)) !== null) {
                if (match.index >= startIndex) {
                    return str.slice(0, match.index) + replacement + str.slice(globalRegex.lastIndex);
                }
            }
            return str;
        }


        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1)); // Random index
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
            return array;
        }


        //main
        document.addEventListener("DOMContentLoaded", async function () {
            initError()
            await loadAIReply()
            loadChatData()

            if (verifyInputs() === false) {
                await saveData()
                return
            }

            if (await handleSwipe()) return

            //main func start here
            const regexDialogues = /"[^"]+?"/gi
            let dialogues = getMatches(regexDialogues, input)

            const regexAIWords = /(?<=<words>)([\S\s](?!<words>))+?(?=<\/words>)/i
            const wordsFromAI = regexAIWords.test(input) ? input.match(regexAIWords)[0] : ""
            const regexWords = /[\w]+/gi
            let words = getWords(regexWords, wordsFromAI)
            let extraWords = shuffleArray([...EXTRA_WORDS])
            words = [...words, extraWords[0], extraWords[1], extraWords[2], extraWords[3], extraWords[4]]

            initUI(dialogues, words)

            doneBtn.addEventListener("click", async function () {
                const blanks = get("blank")
                let modCount = 0
                blanks.forEach(b => {
                    if (b.lastInteract == null) {
                        return
                    }
                    let assocEntry = assoc.filter(a => a.blankId === b.id)[0]
                    dialogues[assocEntry.dialogueIdx].match = replaceAtIndex(dialogues[assocEntry.dialogueIdx].match, escapeRegExp(assocEntry.orig), b.lastInteract.text, assocEntry.idx)

                    if(assocEntry.orig !== b.lastInteract.text) {
                        modCount += 1
                    }
                });

                //replace update aimes
                let fin = input
                dialogues.forEach(d => {
                    fin = replaceAtIndex(input, escapeRegExp(d.original), d.match, d.index)
                });
                modifyAIMes(fin, input)
                updateJB(fin, input, modCount)
                saveData()
            })

            saveData()

            document.querySelector("body").style.height = "fit-content"
        })


        async function updateJB(manipulated, orig, modCount) {
            if(modCount === 0) {
                return
            }

            toJB = `- {{user}} manipulated some dialogues. Here are the changes:

Original:
${orig}

New:
${manipulated}
`

            await insertOrAssignVariables({ jbout: toJB })
            toJB = ""
        }

    </script>
</body>

</html>
```