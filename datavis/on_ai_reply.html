{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- <script src="https://unpkg.com/kaplay@4000.0.0-alpha.22/dist/kaplay.js"></script> -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            margin: 0;
            width: 100%;
            height: fit-content;
        }

        #main_cont {
            margin: 0 auto;
            width: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            /* background-color: aqua; */
        }

        canvas {
            margin: 0 auto;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 3px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont">
        <div id="graph"></div>
    </div>

    <script>
        const main_cont = document.getElementById("main_cont")
        // const game = document.querySelector("canvas")


        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                error.style.display = "none"
            })
        }


        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipe_id]
            const regexInput = /<graph>([\S\s](?!<graph>))+?<\/graph>/i
            input = regexInput.test(input) ? (input.match(regexInput))[0] : ""
        }


        let toJB = ""
        let gameOver
        let aiMesChanged
        let userMesEdited
        let currSwipeId
        let expectingOutputOnId
        let chatData
        let chatDataHist
        let toUserProcess = {}
        function loadChatData() {
            //with history
            chatDataHist = getVariables().chatDataHist == null ? null : JSON.parse(getVariables().chatDataHist)
            chatData = chatDataHist == null ? null : chatDataHist[chatMessages.message_id - 1]

            //without history
            // chatData = getVariables().chatData == null ? null : JSON.parse[getVariables().chatData]

            if (chatData == null) {
                chatData = {}
                chatDataHist = {}
                gameOver = false
                aiMesChanged = false
                userMesEdited = false
                expectingOutputOnId = -1
                currSwipeId = 0
            }
            else {
                gameOver = chatData.gameOver
                aiMesChanged = chatData.aiMesChanged
                expectingOutputOnId = chatData.expectingOutputOnId
            }
        }


        async function saveData() {
            chatData.gameOver = gameOver
            chatData.aiMesChanged = aiMesChanged
            chatData.userMesEdited = false
            chatData.toUserProcess = toUserProcess
            chatData.currSwipeId = currSwipeId

            //with history
            chatDataHist[chatMessages.message_id] = chatData
            await triggerSlash(`/setvar key=chatDataHist ${JSON.stringify(chatDataHist)}`)

            //without history
            // await triggerSlash(`/setvar key=chatData ${JSON.stringify(chatData)}`)
        }


        function verifyInputs(toVerify) {
            // if (gameOver) {
            //     main_cont.parentNode.removeChild(main_cont)
            //     return false
            // }

            // const mesId = chatMessages.message_id

            if (input == "") {
                main_cont.style.display = "none"
                error.style.display = "flex"
                return false
            }

            for (const element of toVerify) {
                if (element == "") {
                    main_cont.style.display = "none"
                    error.style.display = "flex"
                    return false
                }
            }

            // if (mesId === 0 || expectingOutputOnId != mesId) {
            //     main_cont.style.display = "none"
            //     error.style.display = "none"
            // }

            return true
        }


        async function handleSwipe() {
            const newGenSwipes = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            if (currSwipeId !== newGenSwipes.swipe_id) {
                const swipeGen = newGenSwipes.swipes[newGenSwipes.swipe_id]
                if (swipeGen === "...") {
                    await saveData()
                    return true
                }
                input = swipeGen
                currSwipeId = newGenSwipes.swipe_id
                aiMesChanged = false
                return false
            }
        }


        //for AI message manipulation
        async function modifyAIMes(msg, origMsg) {
            if (aiMesChanged === false) {
                aiMesChanged = true
                await saveData()

                const regexAlreadyModified = /<details>\s*<summary>Original<\/summary>/i
                if (regexAlreadyModified.test(msg)) {
                    return
                }

                const toMsg = `${msg}

<hr id="hide">

<details><summary>Original</summary>
${origMsg}
</details>`
                await setChatMessages([{ message_id: '{{lastMessageId}}', message: toMsg }], { refresh: "affected" })
            }
        }


        //main
        document.addEventListener("DOMContentLoaded", async function () {
            // initError()
            // await loadAIReply()
            // loadChatData()

            //intro handler - for multi intro cards
            // if (chatMessages.message_id === 0) {

            // }

            //regexes here
            const regexVar = /regex/i
            const toVer = regexVar.test(input) ? input.match(regexVar)[0] : ""
            const graph = "choropleth"
            //heatmap sample
            // const data = [
            //     { group: "a", x: "v1", y: 10 },
            //     { group: "a", x: "v2", y: 100 },
            //     { group: "a", x: "v3", y: 4 },
            //     { group: "b", x: "v1", y: 75 },
            //     { group: "b", x: "v2", y: 12 },
            //     { group: "b", x: "v3", y: 88 },
            //     { group: "c", x: "v1", y: 100 },
            //     { group: "c", x: "v2", y: 99 },
            //     { group: "c", x: "v3", y: 88 },
            //     { group: "d", x: "v1", y: 99 },
            //     { group: "d", x: "v2", y: 20 },
            //     { group: "d", x: "v3", y: 18 },
            // ]
            //scatter plot sample, line chart
            // const data = [
            //     { x: 0, y: 10 },
            //     { x: 1, y: 100 },
            //     { x: 2, y: 4 },
            //     { x: 3, y: 75 },
            //     { x: 4, y: 12 },
            //     { x: 5, y: 88 },
            //     { x: 6, y: 100 },
            //     { x: 7, y: 99 },
            //     { x: 8, y: 88 },
            //     { x: 9, y: 99 },
            //     { x: 10, y: 20 },
            //     { x: 11, y: 18 },
            // ]
            //bar plot sample
            // const data = [
            //     { x: "wah", y: 10 },
            //     { x: "aaaa", y: 100 },
            //     { x: "wssdah", y: 4 },
            //     { x: "waasdfh", y: 75 },
            //     { x: "fds", y: 12 },
            //     { x: "fsa", y: 88 },
            //     { x: "asd", y: 100 },
            //     { x: "ggds", y: 99 },
            //     { x: "wggdah", y: 88 },
            //     { x: "ssd", y: 99 },
            //     { x: "ssfc", y: 20 },
            //     { x: "vcx", y: 18 },
            // ]
            //pie chart sample
            // const data = { wah: 10, aaaa: 100, wssdah: 4, waasdfh: 75, fds: 12, fsa: 88, asd: 100, ggds: 99, wggdah: 88, ssd: 99, ssfc: 20, vcx: 18 }
            


            const toVerify = []
            if (verifyInputs(toVerify) === false) {
                await saveData()
                return
            }

            // if (await handleSwipe()) return


            //main func start here
            switch (graph) {
                case "heatmap":
                    graphHeatmap(data)
                    break
                case "scatter plot":
                    graphScatterPlot(data)
                    break
                case "barplot":
                    graphBarPlot(data)
                    break
                case "pie chart":
                    graphPieChart(data)
                    break
                case "line chart":
                    graphLineChart(data)
                    break
                case "network":

                    break
            }


            // prepToUserProcess()
            // await updateJB()
            // saveData()
        })


        function prepToUserProcess() {
            //process stuff to be updated on user side

        }


        async function updateJB() {
            await insertOrAssignVariables({ jbout: toJB })
            toJB = ""
        }


        /*****************************************************************
        credits: The D3.js Graph Gallery - https://d3-graph-gallery.com
        *****************************************************************/

        function graphHeatmap(data) {
            // set the dimensions and margins of the graph
            const margin = { top: 30, right: 30, bottom: 30, left: 30 },
                width = 450 - margin.left - margin.right,
                height = 450 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Labels of row and columns
            // const myGroups = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]
            // const myVars = ["v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10"]
            const myGroups = data.map(e => e.group)
            const myVars = data.map(e => e.x)

            // Build X scales and axis:
            const x = d3.scaleBand()
                .range([0, width])
                .domain(myGroups)
                .padding(0.01);
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x))

            // Build X scales and axis:
            const y = d3.scaleBand()
                .range([height, 0])
                .domain(myVars)
                .padding(0.01);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Build color scale
            const myColor = d3.scaleLinear()
                .range(["white", "#69b3a2"])
                .domain([1, 100])

            //Read the data

            // create a tooltip
            const tooltip = d3.select("#graph")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px")

            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                tooltip.style("opacity", 1)
            }
            const mousemove = function (event, d) {
                tooltip
                    .html("The exact value of<br>this cell is: " + d.y)
                    .style("left", (event.x + 70) + "px")
                    .style("top", event.y + "px")
            }
            const mouseleave = function (d) {
                tooltip.style("opacity", 0)
            }

            // add the squares
            svg.selectAll()
                .data(data, function (d) { return d.group + ':' + d.x; })
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.group) })
                .attr("y", function (d) { return y(d.x) })
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return myColor(d.y) })
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
        }


        function graphScatterPlot(data) {
            // set the dimensions and margins of the graph
            const margin = { top: 10, right: 30, bottom: 30, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add X axis
            const x = d3.scaleLinear()
                .domain([d3.min(data, d => d.x) - 3, d3.max(data, d => d.x) + 3])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));
            // Add Y axis
            const y = d3.scaleLinear()
                .domain([d3.min(data, d => d.y) - 3, d3.max(data, d => d.y) + 3])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Add the points
            svg
                .append("g")
                .selectAll("dot")
                .data(data)
                .join("circle")
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .attr("r", 5)
                .attr("fill", "#69b3a2")
        }


        function graphBarPlot(data) {
            // set the dimensions and margins of the graph
            const margin = { top: 30, right: 30, bottom: 70, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // X axis
            const x = d3.scaleBand()
                .range([0, width])
                .domain(data.map(d => d.x))
                .padding(0.2);
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end");

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([d3.min(data, d => d.y), d3.max(data, d => d.y)])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Bars
            svg.selectAll("mybar")
                .data(data)
                .join("rect")
                .attr("x", d => x(d.x))
                .attr("y", d => y(d.y))
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d.y))
                .attr("fill", "#69b3a2")
        }


        function graphPieChart(data) {
            // set the dimensions and margins of the graph
            const width = 450,
                height = 450,
                margin = 40;

            // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
            const radius = Math.min(width, height) / 2 - margin

            // append the svg object to the div called 'my_dataviz'
            const svg = d3.select("#graph")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2},${height / 2})`);

            // Create dummy data
            // const data = {a: 9, b: 20, c:30, d:8, e:12, f:3, g:7, h:14}

            // set the color scale
            const color = d3.scaleOrdinal()
                .domain(Object.keys(data))
                .range(d3.schemeDark2);

            // Compute the position of each group on the pie:
            const pie = d3.pie()
                .sort(null) // Do not sort group by size
                .value(d => d[1])
            const data_ready = pie(Object.entries(data))

            // The arc generator
            const arc = d3.arc()
                .innerRadius(radius * 0.5)         // This is the size of the donut hole
                .outerRadius(radius * 0.8)

            // Another arc that won't be drawn. Just for labels positioning
            const outerArc = d3.arc()
                .innerRadius(radius * 0.9)
                .outerRadius(radius * 0.9)

            // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
            svg
                .selectAll('allSlices')
                .data(data_ready)
                .join('path')
                .attr('d', arc)
                .attr('fill', d => color(d.data[1]))
                .attr("stroke", "white")
                .style("stroke-width", "2px")
                .style("opacity", 0.7)

            // Add the polylines between chart and labels:
            svg
                .selectAll('allPolylines')
                .data(data_ready)
                .join('polyline')
                .attr("stroke", "black")
                .style("fill", "none")
                .attr("stroke-width", 1)
                .attr('points', function (d) {
                    const posA = arc.centroid(d) // line insertion in the slice
                    const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                    const posC = outerArc.centroid(d); // Label position = almost the same as posB
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                    posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
                    return [posA, posB, posC]
                })

            // Add the polylines between chart and labels:
            svg
                .selectAll('allLabels')
                .data(data_ready)
                .join('text')
                .text(d => d.data[0])
                .attr('transform', function (d) {
                    const pos = outerArc.centroid(d);
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                    pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
                    return `translate(${pos})`;
                })
                .style('text-anchor', function (d) {
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                    return (midangle < Math.PI ? 'start' : 'end')
                })
        }


        function graphLineChart(data) {
            // set the dimensions and margins of the graph
            var margin = { top: 10, right: 30, bottom: 30, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#graph")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Add X axis --> it is a date format
            var x = d3.scaleLinear()
                .domain([d3.min(data, d => d.x), d3.max(data, d => d.x)])
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, d3.max(data, function (d) { return +d.y; })])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y));

            // Add the area
            svg.append("path")
                .datum(data)
                .attr("fill", "#cce5df")
                .attr("stroke", "#69b3a2")
                .attr("stroke-width", 1.5)
                .attr("d", d3.area()
                    .x(function (d) { return x(d.x) })
                    .y0(y(0))
                    .y1(function (d) { return y(d.y) })
                )

        }














    </script>
</body>

</html>
```