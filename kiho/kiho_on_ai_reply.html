{{match}}

```html
<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
        integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/kaplay@4000.0.0-alpha.22/dist/kaplay.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8em;
            margin: 0;
            width: 100%;
            height: fit-content;
        }

        #main_cont {
            margin: 0 auto;
            width: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            margin-bottom: 5px;
            padding: 10px;
            color: #dcd1d1;
            background-image: url("https://t3.ftcdn.net/jpg/06/22/33/36/360_F_622333621_KwEUCiaY27QCk5Bi9ujUcQmuTBY5ljt3.jpg");
            background-position: center;
        }

        canvas {
            margin: 0 auto;
        }

        #error {
            margin: 0 auto;
            width: 400px;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 20px;
            border-radius: 7px;
            background-color: rgb(185, 185, 185);
            padding: 5px;
        }

        #ignore_btn {
            background-color: rgb(184, 48, 48);
        }

        .stylized-button {
            color: white;
            padding: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .stylized-button:hover {
            transform: scale(1.05);
        }

        .stylized-button:active {
            transform: scale(0.95);
        }

        #legPOI {
            background: rgb(229, 229, 80);
        }

        #legCache {
            background: rgb(80, 229, 199);
        }

        #legEnemy {
            background: rgb(224, 18, 39);
        }

        #legBase {
            background: rgb(32, 245, 22);
        }

        #legChar {
            background: rgb(237, 88, 237);
        }

        .entityLegend {
            width: 20px;
            height: 20px;
            border-radius: 50%
        }

        .legend {
            display: flex;
            gap: 10px;
        }

        #legUI {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #moveEntitiesBtn {
            background-color: darkcyan;
        }
    </style>
</head>

<body>
    <div id="error">
        <div>
            <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div id="error_msg">
            The AI did not generate the expected output. Please swipe or regenerate. If this is the intro, you
            should ignore this.
        </div>
        <button class="stylized-button" id="ignore_btn">Ignore</button>
    </div>
    <div id="main_cont">
        <button id="moveEntitiesBtn" class="stylized-button">Move</button>
        <div id="legUI">
            <div class="legend">
                <div id="legChar" class="entityLegend"></div>
                <div>{{char}}</div>
            </div>
            <div class="legend">
                <div id="legPOI" class="entityLegend"></div>
                <div>POI</div>
            </div>
            <div class="legend">
                <div id="legCache" class="entityLegend"></div>
                <div>Cache</div>
            </div>
            <div class="legend">
                <div id="legEnemy" class="entityLegend"></div>
                <div>Fog creature</div>
            </div>
            <div class="legend">
                <div id="legBase" class="entityLegend"></div>
                <div>{{user}}'s bunker entrance</div>
            </div>
        </div>
    </div>

    <script>
        const main_cont = document.getElementById("main_cont")
        const moveEntitiesBtn = document.getElementById("moveEntitiesBtn")
        const CANVAS_WIDTH = 514
        const CANVAS_HEIGHT = 485

        kaplay({
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
        })
        const game = document.querySelector("canvas")


        //ai side
        const error = document.getElementById("error")
        function initError() {
            const error_msg = document.getElementById("error_msg")
            const errorIgnoreBtn = document.getElementById("ignore_btn")
            errorIgnoreBtn.addEventListener("click", function () {
                main_cont.style.display = "flex"
                error.style.display = "none"
            })
        }


        //ai side
        let chatMessages
        let input
        async function loadAIReply() {
            chatMessages = await getChatMessages('{{lastMessageId}}', { include_swipes: true })[0]
            input = chatMessages.swipes[chatMessages.swipes.length - 1]
            const regexInput = /<move>([\S\s](?!<move>))+?<\/move>/i
            input = regexInput.test(input) ? (input.match(regexInput))[0] : ""
        }


        let toJB = ""
        let gameOver
        let userMesEdited
        let chatData
        let chatDataHist
        let toUserProcess = {}
        let entitiesMove = false
        let entInMotion = []
        let excludeOnSave = []
        let ammoRemaining
        //ai side
        function loadChatData() {
            chatDataHist = getVariables().chatDataHist == null ? null : JSON.parse(getVariables().chatDataHist)
            chatData = chatDataHist == null ? null : chatDataHist[chatMessages.message_id - 1]
            if (chatData == null) {
                chatData = {}
                chatDataHist = {}
                gameOver = false
                ammoRemaining = 20
            }
            else {
                gameOver = chatData.gameOver
                ammoRemaining = chatData.ammoRemaining
            }
        }


        //ai side
        async function saveData() {
            chatData.gameOver = gameOver
            chatData.userMesEdited = false
            saveEntities()
            chatData.toUserProcess = toUserProcess
            chatDataHist[chatMessages.message_id] = chatData
            await triggerSlash(`/setvar key=chatDataHist ${JSON.stringify(chatDataHist)}`)
        }


        function saveEntities() {
            const entities = get("entity")
            let entitiesToSave = []
            entities.forEach(entity => {
                if (excludeOnSave.includes(entity.id)) {
                    return
                }
                const newEntry = {
                    pos: entity.pos.serialize(),
                    tags: entity.tags
                }
                entitiesToSave.push(newEntry)
            });
            toUserProcess.savedEntities = entitiesToSave
        }


        //ai side
        function verifyInputs(toVerify) {
            if (gameOver) {
                game.parentNode.removeChild(game)
                main_cont.parentNode.removeChild(main_cont)
                updateJB()
                saveData()
                return false
            }

            const mesId = chatMessages.message_id

            for (const element of toVerify) {
                if (element === "") {
                    main_cont.style.display = "none"
                    error.style.display = "flex"
                    return false
                }
            }

            if (input === "") {
                main_cont.style.display = "none"
                error.style.display = "flex"
                return false
            }

            return true
        }

        const ENTITY_SPEED = 1000

        function newEntities() {
            //user
            add([
                sprite("entity"),
                anchor("center"),
                scale(0.1),
                area({
                    scale: 1,
                }),
                pos(CANVAS_WIDTH / 2, CANVAS_HEIGHT - 15),
                "entity",
                "user"
            ])

            //char
            add([
                sprite("entity"),
                scale(0.1),
                anchor("center"),
                area({
                    scale: 1.5,
                }),
                pos(rand(15, CANVAS_WIDTH - 15), 15),
                "entity",
                "char",
            ])

            //weapons cache
            let cacheCount = randi(3, 6)
            for (let i = 0; i < cacheCount; i++) {
                add([
                    sprite("entity"),
                    anchor("center"),
                    scale(0.1),
                    area({
                        scale: 1,
                    }),
                    pos(rand(35, CANVAS_WIDTH - 35), rand(35, CANVAS_HEIGHT - 35)),
                    "entity",
                    "cache"
                ])
            }

            //poi - loc, mystery
            let poiCount = randi(1, 6)
            for (let i = 0; i < poiCount; i++) {
                add([
                    sprite("entity"),
                    anchor("center"),
                    scale(0.1),
                    area({
                        scale: 1,
                    }),
                    pos(rand(35, CANVAS_WIDTH - 35), rand(35, CANVAS_HEIGHT - 35)),
                    "entity",
                    "poi"
                ])
            }

            //enemies
            let enemyCount = randi(10, 25)
            for (let i = 0; i < enemyCount; i++) {
                const enemy = add([
                    sprite("entity"),
                    anchor("center"),
                    scale(0.1),
                    area({
                        scale: 1,
                    }),
                    pos(rand(15, CANVAS_WIDTH - 15), rand(CANVAS_HEIGHT / 2 - 100, CANVAS_HEIGHT / 2 + 100)),
                    "entity",
                    "enemy"
                ])

                enemy.tag(getRandomEnemyType())
            }
        }


        function loadEntities() {
            chatData.savedEntities.forEach(entry => {
                const entity = add([
                    sprite("entity"),
                    scale(0.1),
                    anchor("center"),
                    area({
                        scale: 1,
                    }),
                    pos(entry.pos.x, entry.pos.y),
                ])
                entity.tag(entry.tags)
            });
        }


        //514x485
        function initCanvas(aiMove) {
            //background
            loadSprite("bg", "https://files.catbox.moe/17ru8j.jpg")
            add([
                sprite("bg", {
                    tiled: true,
                }),
                z(-1),
                scale(0.75),
                pos(-30, -15)
            ])

            //entities
            loadShader("blinking",
                null,
                //amp * sin(freq * u_time + start)
                `uniform float u_time;
                uniform vec4 u_color;
                vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {
                    float blink = sin(5.0 * u_time);
                    return def_frag() * vec4(1.0, 1.0, 1.0, blink <= 0.2 ? 1.0 : 0.0);
                }`
            )

            loadSprite("entity", "https://files.catbox.moe/astm2u.png")

            if (chatMessages.message_id === 0) {
                newEntities()
            }
            else {
                loadEntities()
            }

            //comp entities
            const user = get("user")[0]
            user.use(color(32, 245, 22))

            function charMove() {
                let steps = 200
                let moving = true
                let v

                return {
                    id: "charMove",
                    add() {
                        entInMotion.push(this.id)
                        aiMove = aiMove.toLowerCase().trim()
                        switch (aiMove) {
                            case "wait":
                                v = vec2(0, 0)
                                steps = 0
                                break
                            case "n":
                                v = vec2(0, -1)
                                break
                            case "e":
                                v = vec2(1, 0)
                                break
                            case "w":
                                v = vec2(-1, 0)
                                break
                            case "s":
                                v = vec2(0, 1)
                                break
                            case "ne":
                                v = vec2(1, -1).unit()
                                break
                            case "nw":
                                v = vec2(-1, -1).unit()
                                break
                            case "se":
                                v = vec2(1, 1).unit()
                                break
                            case "sw":
                                v = vec2(-1, 1).unit()
                                break
                            default: console.error("No direction detected.")
                        }
                    },
                    update() {
                        if (moving && entitiesMove && steps > 0) {
                            //get input from ai
                            let step = vec2(v.x * ENTITY_SPEED * dt(), v.y * ENTITY_SPEED * dt())
                            this.move(step)
                            steps -= 1
                        }
                        else if (moving && entitiesMove && steps <= 0) {
                            moving = false
                            steps = 0
                            entInMotion = entInMotion.filter(ent => ent !== this.id)
                        }
                        else if(entInMotion.length === 0) {
                            moving = false
                            steps = 0
                        }
                    },
                }
            }

            const char = get("char")[0]
            char.use(charMove(char))
            char.use(shader("blinking", () => ({
                u_time: time(),
            })))
            char.use(color(237, 88, 237))
            char.use(area({
                scale: 1.5,
            }))

            const caches = get("cache")
            caches.forEach(cache => {
                cache.use(color(80, 229, 199))
            });

            const pois = get("poi")
            pois.forEach(poi => {
                poi.use(color(229, 229, 80))
            });

            const enemies = get("enemy")
            enemies.forEach(enemy => {
                enemy.use(color(224, 18, 39))
            });

            //enemies
            function wander() {
                const wanderSteps = [
                    0, 0, 0, 100, 200, 300, 400
                ]
                let steps = wanderSteps[Math.floor(Math.random() * wanderSteps.length)]
                let wandering = true
                let v = vec2(randi(-1, 2), randi(-1, 2)).unit()

                return {
                    id: "wander",
                    add() {
                        entInMotion.push(this.id)
                    },
                    update() {
                        if (wandering && entitiesMove && steps > 0) {
                            let step = vec2(v.x * ENTITY_SPEED * dt(), v.y * ENTITY_SPEED * dt())
                            if (this.pos.x <= 5 || this.pos.x >= CANVAS_WIDTH - 5 || this.pos.y <= 5 || this.pos.y >= CANVAS_HEIGHT - 5) {
                                this.move(step.x * -1, step.y * -1)
                            }
                            else {
                                this.move(step)
                            }
                            steps -= 1
                        }
                        else if (wandering && entitiesMove && steps <= 0) {
                            wandering = false
                            steps = 0
                            entInMotion = entInMotion.filter(ent => ent !== this.id)
                        }
                        else if(entInMotion.length === 0) {
                            wandering = false
                            steps = 0
                        }
                    },
                }
            }

            function track() {
                let steps = 200
                let tracking = true
                let v

                return {
                    id: "track",
                    add() {
                        entInMotion.push(this.id)
                        let ch = get("char")[0]
                        v = ch.pos.sub(this.pos).unit()
                    },
                    update() {
                        if (tracking && entitiesMove && steps > 0) {
                            let step = vec2(v.x * ENTITY_SPEED * dt(), v.y * ENTITY_SPEED * dt())
                            if (this.pos.x <= 5 || this.pos.x >= CANVAS_WIDTH - 5 || this.pos.y <= 5 || this.pos.y >= CANVAS_HEIGHT - 5) {
                                this.move(step.x * -1, step.y * -1)
                            }
                            else {
                                this.move(step)
                            }
                            steps -= 1
                        }
                        else if (tracking && entitiesMove && steps <= 0) {
                            tracking = false
                            steps = 0
                            entInMotion = entInMotion.filter(ent => ent !== this.id)
                        }
                        else if(entInMotion.length === 0) {
                            tracking = false
                            steps = 0
                        }
                    },
                }
            }

            const UNCLOAK_DIST = 60
            function cloak() {
                return {
                    id: "cloak",
                    add() {
                        this.opacity = 0
                    },
                    update() {
                        let dist = get("char")[0].pos.dist(this.pos)
                        if (dist >= UNCLOAK_DIST) {
                            this.opacity = 0
                        }
                        else {
                            this.opacity = UNCLOAK_DIST / dist
                        }
                    },
                }
            }

            //enemy special props
            const mimics = get("mimic")
            mimics.forEach(mimic => {
                mimic.color = rgb(80, 229, 199)
            });

            const shamblers = get("shambler")
            shamblers.forEach(shambler => {
                shambler.use(wander())
            });

            const trackers = get("tracker")
            trackers.forEach(tracker => {
                tracker.use(track())
            });

            const invisibles = get("invisible")
            invisibles.forEach(invisible => {
                invisible.use(cloak())
            })

            const brutes = get("brute")
            brutes.forEach(brute => {
                brute.scale = vec2(0.22)
            });

            onCollide("char", "enemy", (char, enemy) => {
                excludeOnSave.push(enemy.id)
                enemy.use(shader("blinking", () => ({
                    u_time: time(),
                })))

                toJB = `- {{char}} is now face to face with a fog creature.
- {{char}} has ${ammoRemaining} ammo remaining. She must use some of them or she dies.
`
                if (enemy.is("mimic")) {
                    toJB += `- The fog creature is mimicking a weapon crate and now revealed its true appearance.
`
                }
                if (enemy.is("brute")) {
                    toJB += `- The fog creature is some kind of brute. Gigantic and tough. She'll have to use all her ammo to take this creature down.
`
                }
                if(enemy.is("invisible")){
                    toJB += `- The fog creature has an ability to remain invisible in {{user}}'s radar.
`
                }
                if (ammoRemaining === 0) {
                    gameOver = true
                    toJB += `- {{char}} ran out of ammo, she cannot escape nor fight the creature hand to hand.
- She dies in this encounter. Game over.
`
                }

                entitiesMove = false
                entInMotion = []
                prepToUserProcess("")
                updateJB()
                saveData()
            })

            onCollide("char", "poi", (char, poi) => {
                excludeOnSave.push(poi.id)
                poi.use(shader("blinking", () => ({
                    u_time: time(),
                })))

                toJB = `- {{char}} finds something. It's {{random::a trinket::a human corpse holding something.::a creature's corpse with something in it.::a strange mark.::something weird she cannot explain.}}
`
                entitiesMove = false
                entInMotion = []
                prepToUserProcess("- NO fog creatures in {{char}}'s sight yet.")
                updateJB()
                saveData()
            })

            onCollide("char", "cache", (char, cache) => {
                excludeOnSave.push(cache.id)
                cache.use(shader("blinking", () => ({
                    u_time: time(),
                })))

                let ammoInc = [5, 10, 15, 20, 30, 40, 50]
                ammoInc = ammoInc[Math.floor(Math.random() * ammoInc.length)]
                ammoRemaining += ammoInc
                toJB = `- {{char}} finds a scavenged weapon's cache. Ammo count: +${ammoInc}. Her ammo reserves are now at ${ammoRemaining}.
`
                entitiesMove = false
                entInMotion = []
                prepToUserProcess("- NO fog creatures in {{char}}'s sight yet.")
                updateJB()
                saveData()
            })

            onCollide("char", "user", (char, user) => {
                gameOver = true
                user.use(shader("blinking", () => ({
                    u_time: time(),
                })))

                toJB = `- {{char}} finally reached the bunker.
`
                entitiesMove = false
                entInMotion = []
                updateJB()
                saveData()
            })
        }


        const enemyTypes = [
            "stationary",
            "stationary",
            "stationary",
            "mimic",
            "shambler",
            "shambler",
            "shambler",
            "tracker",
            "tracker",
            "tracker",
            "invisible",
            "invisible",
            "brute",
            "brute"
        ]
        function getRandomEnemyType() {
            let specialCount = [1, 1, 1, 1, 2, 2, 3, 3]
            specialCount = specialCount[Math.floor(Math.random() * specialCount.length)]
            let outputArr = []
            for (let i = 0; i < specialCount; i++) {
                outputArr.push(enemyTypes[Math.floor(Math.random() * enemyTypes.length)])
            }
            //mimic - only 1
            //conflicts: shambler, tracker, stationary
            if (outputArr.indexOf("mimic") != -1) {
                outputArr = outputArr.filter(e => e === "mimic")
            }
            else if (outputArr.indexOf("tracker") != -1) {
                outputArr = outputArr.filter(e => e !== "shambler")
                    .filter(e => e !== "stationary")
            }
            else if (outputArr.indexOf("shambler") != -1) {
                outputArr = outputArr.filter(e => e !== "tracker")
                    .filter(e => e !== "stationary")
            }
            else if (outputArr.indexOf("stationary") != -1) {
                outputArr = outputArr.filter(e => e !== "tracker")
                    .filter(e => e !== "shambler")
            }
            outputArr = [...new Set(outputArr)]
            return outputArr
        }


        //main
        document.addEventListener("DOMContentLoaded", async function () {
            //ai
            initError()
            await loadAIReply()

            //ai user
            loadChatData()

            //ai
            //regexes here
            const regexMove = /[NEWS]\s|[NS][EW]\s|wait/i
            const aiMove = regexMove.test(input) ? input.match(regexMove)[0] : ""
            const regexAmmoCount = /\d+/i
            let ammoCount = regexAmmoCount.test(input) ? input.match(regexAmmoCount)[0] : ""

            const toVerify = [aiMove, ammoCount]
            if (verifyInputs(toVerify) === false) {
                await saveData()
                return
            }

            ammoCount = parseInt(ammoCount)

            //main func start here
            ammoRemaining -= ammoCount
            initCanvas(aiMove)
            moveEntitiesBtn.addEventListener("click", function () {
                entitiesMove = true
                moveEntitiesBtn.style.visibility = "hidden"
            })
            onUpdate(() => {
                if (entInMotion.length <= 0 && entitiesMove) {
                    entitiesMove = false
                    saveData()
                }
            })

            //ai
            prepToUserProcess("- NO fog creatures in {{char}}'s sight yet.")
            updateJB()
            saveData()
            document.querySelector("body").style.height = "fit-content"
        })


        //ai side
        function prepToUserProcess(prepend) {
            //process stuff to be updated on user side
            toUserProcess.ammoRemaining = Math.max(0, ammoRemaining)

            if (gameOver) {
                return
            }
            toJB += `${prepend}
- Only a radio connects {{user}} and {{char}}.
- {{user}} has a radar that can map the creature's movements. This intel is only available through {{user}}. As such, you cannot make up your own encounter for {{char}}.
- {{user}} cannot see what {{char}} is doing. Describe the sounds that can be heard in the radio immersively through narration and the way in which {{char}} describes what she can see through dialogue.
- Focus only on the surroundings of {{char}}.
- At the end {{char}}'s response, please include the following:
<move>
[Direction {{char}} will move next]
[Ammo count used for this encounter]
</move>

- The directions are N (north), E (east), W (west), S (south), NE (northeast), NW (northwest), SE (southeast) and SW (southwest), which are represented by the first letter of the direction names. Put 'Wait' if she remains still.
- Ammo count used is a number. Range from 0 to ${ammoRemaining}.

- Here's an example, where {{char}} will move south and hasn't used any ammo.
<move>
S
0
</move>

- Another example, where {{char}} will remain still and shoots her gun 5 times.
<move>
Wait
5
</move>
`
        }


        //ai side
        async function updateJB() {
            await insertOrAssignVariables({ jbout: toJB })
            //toJB = ""
        }
    </script>
</body>

</html>
```